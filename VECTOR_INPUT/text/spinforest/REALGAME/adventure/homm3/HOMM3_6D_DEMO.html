<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üè∞ HOMM3 6D - Adventure Temporelle</title>
    <link rel="stylesheet" href="DARK_ELITE_THEME.css">
    <link rel="stylesheet" href="MINIMAL_OVERRIDE.css">
    <style>
        /* OVERRIDE pour supprimer le rose et utiliser le th√®me sombre */
        
        /* OVERRIDE COMPLET DU STYLE ROSE */
        .header, .left-panel, .right-panel, .controls {
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.8) 0%, rgba(10, 10, 20, 0.6) 50%, rgba(30, 20, 40, 0.8) 100%) !important;
            border: 1px solid rgba(100, 80, 120, 0.3) !important;
            border-radius: 15px !important;
            backdrop-filter: blur(20px) !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.1), inset 0 -1px 0 rgba(0, 0, 0, 0.5) !important;
        }
        
        .title {
            color: #c0a080 !important;
            text-shadow: 0 0 20px rgba(192, 160, 128, 0.5), 0 2px 4px rgba(0, 0, 0, 0.8) !important;
            font-family: 'Cinzel', 'Garamond', serif !important;
            text-transform: uppercase !important;
            letter-spacing: 4px !important;
        }
        
        .section h3 {
            color: #c0a080 !important;
            text-shadow: 0 0 10px rgba(192, 160, 128, 0.3) !important;
        }
        
        .btn {
            background: linear-gradient(135deg, rgba(40, 30, 50, 0.8) 0%, rgba(30, 20, 40, 0.6) 100%) !important;
            color: #c0a080 !important;
            border: 1px solid rgba(100, 80, 120, 0.4) !important;
            text-transform: uppercase !important;
            letter-spacing: 1px !important;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, rgba(60, 45, 75, 0.9) 0%, rgba(50, 35, 65, 0.8) 100%) !important;
            color: #d4b896 !important;
            border-color: rgba(120, 100, 140, 0.6) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6), 0 0 20px rgba(192, 160, 128, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
        }
        
        .section {
            border-bottom: 1px solid rgba(100, 80, 120, 0.2) !important;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.online { background: #28a745; box-shadow: 0 0 5px #28a745; }
        .status-dot.offline { background: #dc3545; }
        
        .left-panel {
            background: rgba(0,0,0,0.8);
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
        }
        
        .map-container {
            background: rgba(0,0,0,0.9);
            border: 3px solid #FFD700;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .map-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }
        
        .right-panel {
            background: rgba(0,0,0,0.8);
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            padding: 15px;
            overflow-y: auto;
        }
        
        .controls {
            grid-column: 1 / -1;
            background: rgba(0,0,0,0.8);
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 10px;
        }
        
        .panel-section {
            margin-bottom: 20px;
        }
        
        .panel-title {
            color: #FFD700;
            font-size: 1.1em;
            margin-bottom: 10px;
            border-bottom: 1px solid #8A2BE2;
            padding-bottom: 5px;
        }
        
        .btn {
            background: linear-gradient(45deg, #8A2BE2, #FF1493);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin: 2px;
        }
        
        .btn:hover {
            background: linear-gradient(45deg, #FF1493, #FFD700);
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .slider {
            flex: 1;
            height: 5px;
            background: #333;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #FFD700;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .log-area {
            background: rgba(0,0,0,0.5);
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.3;
        }
        
        .log-entry {
            margin-bottom: 5px;
            opacity: 0.8;
        }
        
        .log-entry.success { color: #28a745; }
        .log-entry.error { color: #dc3545; }
        .log-entry.info { color: #17a2b8; }
        
        .entity-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .entity-item {
            background: rgba(255,255,255,0.1);
            border: 1px solid #666;
            border-radius: 5px;
            padding: 8px;
            margin: 5px 0;
            font-size: 11px;
        }
        
        .entity-item.selected {
            border-color: #FFD700;
            background: rgba(255,215,0,0.2);
        }
        
        .loading {
            display: inline-block;
            width: 10px;
            height: 10px;
            border: 2px solid #8A2BE2;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 5px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .fog-overlay {
            position: absolute;
            pointer-events: none;
            background: radial-gradient(circle, transparent 0%, rgba(100,100,100,0.7) 100%);
        }
        
        .axis-mode {
            background: linear-gradient(45deg, #8B0000, #FF4500) !important;
            box-shadow: 0 0 15px #FF4500;
        }
        
        .time-velocity-display {
            font-size: 10px;
            color: #FFD700;
            text-align: center;
        }
        
        /* üéí INVENTAIRE STYLES */
        .hotbar-slot {
            width: 30px;
            height: 30px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #666;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        
        .hotbar-slot:hover {
            border-color: #8A2BE2;
            background: rgba(138, 43, 226, 0.2);
        }
        
        .hotbar-slot.has-item {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }
        
        .hotbar-slot.cooldown {
            border-color: #FF4500;
            background: rgba(255, 69, 0, 0.1);
            color: #FF4500;
        }
        
        .hotbar-slot .item-icon {
            font-size: 14px;
        }
        
        .hotbar-slot .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #FF4500;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <div class="title">üè∞ HOMM3 6D - Adventure Temporelle</div>
            <div class="status-bar">
                <div>
                    <span class="status-dot" id="rustStatus"></span>
                    Rust: <span id="rustStatusText">...</span>
                </div>
                <div>
                    <span class="status-dot" id="javaStatus"></span>
                    Java: <span id="javaStatusText">...</span>
                </div>
                <button class="btn" onclick="checkServerStatus()">üîÑ Refresh</button>
                <button class="btn" onclick="refreshInventoryFromBackend()">üí∞ Sync Inventory</button>
            </div>
        </div>
        
        <!-- Left Panel - Map Controls -->
        <div class="left-panel">
            <div class="panel-section">
                <div class="panel-title">üó∫Ô∏è Contr√¥les Carte</div>
                <button class="btn" onclick="generateNewMap()">üé≤ Nouvelle Carte</button>
                <button class="btn" onclick="initializeEntities()">üé≠ Placer Entit√©s</button>
                <button class="btn" onclick="showOpenAPIViewer()">üìö OpenAPI Viewer</button>
                <button class="btn" onclick="openCardGallery()">üé¥ Galerie Dark</button>
                <button class="btn" onclick="openCardComparator()">‚öîÔ∏è Comparateur</button>
                <button class="btn" onclick="openArchaeologistBadge()">üè∫ Arch√©ologue du Futur</button>
                <button class="btn" onclick="toggleClippyMemento()">üìé Assistant Memento</button>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üéí Inventaire & Hotbar</div>
                
                <!-- Ressources -->
                <div style="display: flex; justify-content: space-between; margin: 5px 0; font-size: 11px;">
                    <span>üí∞ <span id="goldCount">0</span></span>
                    <span>üíô <span id="manaCount">100</span></span>
                    <span>‚è≥ <span id="crystalCount">0</span></span>
                </div>
                
                <!-- Hotbar (8 slots) -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px; margin: 8px 0;">
                    <div class="hotbar-slot" id="slot0" onclick="useHotbarSlot(0)" data-key="1">1</div>
                    <div class="hotbar-slot" id="slot1" onclick="useHotbarSlot(1)" data-key="2">2</div>
                    <div class="hotbar-slot" id="slot2" onclick="useHotbarSlot(2)" data-key="3">3</div>
                    <div class="hotbar-slot" id="slot3" onclick="useHotbarSlot(3)" data-key="4">4</div>
                    <div class="hotbar-slot" id="slot4" onclick="useHotbarSlot(4)" data-key="5">5</div>
                    <div class="hotbar-slot" id="slot5" onclick="useHotbarSlot(5)" data-key="6">6</div>
                    <div class="hotbar-slot" id="slot6" onclick="useHotbarSlot(6)" data-key="7">7</div>
                    <div class="hotbar-slot" id="slot7" onclick="useHotbarSlot(7)" data-key="8">8</div>
                </div>
                
                <!-- Actions inventaire -->
                <div style="display: flex; gap: 3px;">
                    <button class="btn" onclick="openInventory()" style="flex: 1; font-size: 10px;">üì¶ Ouvrir</button>
                    <button class="btn" onclick="autoHeal()" style="flex: 1; font-size: 10px;">‚ù§Ô∏è Heal</button>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üéÆ Mini-Games</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin: 5px 0;">
                    <button class="btn" onclick="startPanoramixPotions()" style="font-size: 9px;">üßô‚Äç‚ôÇÔ∏è Panoramix</button>
                    <button class="btn" onclick="startSenkuChemistry()" style="font-size: 9px;">üß™ Senku</button>
                    <button class="btn" onclick="startHerbCollection()" style="font-size: 9px;">üåø Collecte</button>
                    <button class="btn" onclick="startRunicForge()" style="font-size: 9px;">‚öíÔ∏è Forge</button>
                </div>
                <div id="activeMinigame" style="font-size: 10px; color: #FFD700; min-height: 20px;">
                    Aucun mini-game actif
                </div>
                <div id="gatheringSkills" style="font-size: 9px; color: #ccc; margin-top: 5px;">
                    Herbalisme: <span id="herbalismLevel">1</span><br>
                    Chimie: <span id="chemistryLevel">1</span><br>
                    Forge: <span id="forgingLevel">1</span>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üíé Artefacts √âquip√©s</div>
                <div id="artifactsList" style="font-size: 10px; color: #ccc; min-height: 30px;">
                    Aucun artefact √©quip√©
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üî¨ Inversion Temporelle</div>
                <div class="slider-container">
                    <span>-1</span>
                    <input type="range" class="slider" id="timeVelocitySlider" 
                           min="-1" max="1" step="0.1" value="1" 
                           onchange="updateTimeVelocity(this.value)">
                    <span>+1</span>
                </div>
                <div class="time-velocity-display" id="timeVelocityDisplay">Vitesse: +1.0 (Normal)</div>
                <button class="btn" id="axisBtn" onclick="toggleAxisMode()">üîÑ Mode Axis</button>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üåÄ Topologie Non-Euclidienne</div>
                <select id="topologySelect" onchange="updateTopology(this.value)" style="width: 100%; padding: 5px; background: rgba(255,255,255,0.1); border: 1px solid #8A2BE2; border-radius: 4px; color: #fff; font-size: 11px;">
                    <option value="plane">üìê Plan Euclidien</option>
                    <option value="torus">üç© Torus (Wrap X/Y)</option>
                    <option value="mobius">‚ôæÔ∏è M√∂bius (Inversion)</option>
                    <option value="klein">üåÄ Klein (Double Wrap)</option>
                </select>
                <div style="font-size: 10px; color: #ccc; margin-top: 5px;" id="topologyDesc">
                    Plan euclidien standard
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üìç Coordonn√©es</div>
                <div style="font-size: 11px;">
                    Cursor: <span id="cursorPos">(-,-)</span><br>
                    Selected: <span id="selectedPos">Aucune</span><br>
                    Causalit√©: <span id="causalityLevel">-</span>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üéØ Qu√™tes Actives</div>
                <div id="questList" style="font-size: 10px; color: #ccc; max-height: 120px; overflow-y: auto;">
                    Chargement...
                </div>
                <div style="margin-top: 5px;">
                    <button class="btn" onclick="showQuestLog()" style="width: 100%; font-size: 10px;">üìú Journal</button>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üìç Localisation</div>
                <div style="font-size: 10px; color: #FFD700;">
                    <div id="currentLocationName">Zone Inconnue</div>
                    <div id="currentLocationDesc" style="color: #ccc; margin-top: 3px; font-size: 9px;">
                        Description de la zone
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üåê World State Graph</div>
                <div style="font-size: 10px; color: #ccc;">
                    Status: <span id="wsgStatus">D√©marrage...</span><br>
                    Entit√©s: <span id="entityCount">0</span><br>
                    Collisions: <span id="collisionCount">0</span><br>
                    Proximit√©: <span id="proximityRadius">1.5</span>
                </div>
                <div style="margin-top: 5px;">
                    <input type="range" min="0.5" max="3.0" step="0.1" value="1.5" 
                           onchange="setProximityRadius(this.value)" 
                           style="width: 100%; height: 15px;">
                </div>
            </div>
        </div>
        
        <!-- Map Container -->
        <div class="map-container">
            <canvas class="map-canvas" id="mapCanvas" width="800" height="600"></canvas>
            <div id="fogOverlay" class="fog-overlay"></div>
        </div>
        
        <!-- Right Panel - Entities & Info -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title">üé≠ Entit√©s Actives</div>
                <div class="entity-list" id="entityList">
                    <div class="entity-item">Aucune entit√© d√©tect√©e</div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üìä WSG Status</div>
                <button class="btn" onclick="pollWorldStateGraph()">üîÑ Poll WSG</button>
                <div style="font-size: 10px; margin-top: 5px;">
                    Derni√®re sync: <span id="lastWSGPoll">Jamais</span>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">üìú Debug Log</div>
                <div class="log-area" id="debugLog"></div>
            </div>
        </div>
        
        <!-- Controls Bar -->
        <div class="controls">
            <button class="btn" onclick="startPathfinding()">üß≠ Planifier Route</button>
            <button class="btn" onclick="startMovement()">üö∂ D√©marrer Mouvement</button>
            <button class="btn" onclick="observeArea()">üëÅÔ∏è Observer Zone</button>
            <button class="btn" onclick="testTopologies()">üåÄ Test Topologies</button>
            <button class="btn" onclick="toggleWSG()">üåê Toggle WSG</button>
            <button class="btn" onclick="forceCollisionCheck()">‚öîÔ∏è Check Collisions</button>
            <button class="btn" onclick="testTCG()">üÉè Test TCG</button>
            <button class="btn" onclick="showQuestLog()">üìú Quest Log</button>
            <button class="btn" onclick="clearAll()">üóëÔ∏è Clear All</button>
            
            <!-- üó®Ô∏è COMMANDES MINI-GAMES -->
            <div style="margin-top: 10px; display: flex; gap: 5px;">
                <input type="text" id="commandInput" placeholder="craft potion_vie | chemistry aqua_regia | collect" 
                       style="flex: 1; padding: 5px; background: rgba(255,255,255,0.1); border: 1px solid #8A2BE2; border-radius: 3px; color: #fff; font-size: 11px;"
                       onkeypress="if(event.key==='Enter') executeCommand()">
                <button class="btn" onclick="executeCommand()" style="font-size: 10px;">‚ö° CMD</button>
            </div>
        </div>
    </div>

    <!-- Include modules -->
    <script src="map.js"></script>
    <script src="movement.js"></script>
    <script src="fog.js"></script>
    <script src="inventory.js"></script>
    <script src="wsg.js"></script>
    <script src="tcg.js"></script>
    <script src="quest.js"></script>
    <script src="economy-backend.js"></script>
    <script src="minigames.js"></script>
    <script src="temporal-drift.js"></script>
    <script src="drift-hud.js"></script>
    <script src="xp-system.js"></script>
    <script src="persistence-system.js"></script>
    
    <script>
        // üöÄ VARIABLES GLOBALES
        let map, movement, fog, inventory, wsg, questSystem, minigames, economyBackend;
        let temporalDrift, driftHUD;
        let xpSystem, persistenceSystem;
        let canvas, ctx;
        let selectedEntity = null;
        let isAxisMode = false;
        let currentTimeVelocity = 1.0;
        let currentTopology = 'plane'; // üåÄ NOUVEAU: Topologie active
        let wsgPollInterval = null;
        
        // üîß CONFIGURATION XP AUTO-BACKEND (Updated per API.md)
        const XP_CONFIG = {
            backendAutoXP: {
                resolve: true,    // ‚úÖ Backend donne XP automatiquement sur resolve (idempotent)
                collapse: true,   // ‚úÖ Backend donne XP automatiquement sur collapse (idempotent avec playerId)  
                tcg: true,        // ‚úÖ Backend donne XP automatiquement apr√®s TCG
                collect: false,   // ‚ùå Backend ne donne pas encore XP sur collecte (mais inf√®re item kind)
                craft: false,     // ‚ùå Backend ne donne pas encore XP sur craft
                arcade: false     // ‚ùå Backend ne donne pas encore XP sur arcade
            }
        };
        
        // üéØ INITIALISATION
        document.addEventListener('DOMContentLoaded', async function() {
            canvas = document.getElementById('mapCanvas');
            ctx = canvas.getContext('2d');
            
            // Charger les ressources
            const resourcesResponse = await fetch('resources.json');
            const resources = await resourcesResponse.json();
            
            // Initialiser les modules selon les conseils du coll√®gue
            map = new HOMM3Map(resources.api_endpoints);
            movement = new HOMM3Movement(map);
            fog = new HOMM3CausalityFog(map);
            inventory = new InventorySystem(map);
            wsg = new WSGSystem(map);
            questSystem = new QuestSystem(map, inventory);
            economyBackend = new EconomyBackend();
            minigames = new MinigameSystem(inventory, questSystem, economyBackend);
            
            // üöó Temporal Drift System
            temporalDrift = new TemporalDriftSystem();
            driftHUD = new TemporalDriftHUD(temporalDrift);
            
            // üèÜ XP System
            xpSystem = new XPSystem();
            
            // üíæ Persistence System
            persistenceSystem = new PersistenceSystem();
            
            // Callbacks pour les √©v√©nements
            setupEventCallbacks();
            setupInventoryCallbacks();
            setupWSGCallbacks();
            setupQuestCallbacks();
            setupMinigameCallbacks();
            setupEconomyBackendCallbacks();
            setupXPCallbacks();
            setupPersistenceCallbacks();
            setupTemporalDriftCallbacks();
            updateInventoryUI();
            updateQuestUI();
            
            // Charger inventaire initial depuis le backend
            refreshInventoryFromBackend();
            
            // D√©marrer WSG polling
            wsg.start();
            
            // üöó D√©marrer Temporal Drift
            temporalDrift.start();
            
            // V√©rifier les serveurs
            await checkServerStatus();
            
            // Configurer les √©v√©nements de canvas
            setupCanvasEvents();
            
            // D√©marrer le polling WSG (comme conseill√©)
            startWSGPolling();
            
            log('‚úÖ HOMM3 6D Demo initialis√© avec les APIs Magic Stack', 'success');
        });
        
        // üì° V√âRIFICATION SERVEURS
        async function checkServerStatus() {
            try {
                // Test Rust
                const rustResponse = await fetch('http://localhost:3001/openapi');
                updateServerStatus('rust', rustResponse.ok);
                
                // Test Java
                const javaResponse = await fetch('http://localhost:8082/api');
                updateServerStatus('java', javaResponse.ok);
                
            } catch (error) {
                updateServerStatus('rust', false);
                updateServerStatus('java', false);
            }
        }
        
        function updateServerStatus(server, isOnline) {
            const statusDot = document.getElementById(`${server}Status`);
            const statusText = document.getElementById(`${server}StatusText`);
            
            if (isOnline) {
                statusDot.className = 'status-dot online';
                statusText.textContent = 'EN LIGNE';
                statusText.style.color = '#28a745';
            } else {
                statusDot.className = 'status-dot offline';
                statusText.textContent = 'HORS LIGNE';
                statusText.style.color = '#dc3545';
            }
        }
        
        // üó∫Ô∏è G√âN√âRATION CARTE
        async function generateNewMap() {
            log('üé≤ G√©n√©ration nouvelle carte...', 'info');
            
            try {
                // V√©rifier que les modules sont initialis√©s
                if (!map) {
                    log('‚ùå Module map non initialis√©', 'error');
                    return;
                }
                if (!fog) {
                    log('‚ùå Module fog non initialis√©', 'error');
                    return;
                }
                
                await map.generateMap({
                    width: 48,
                    height: 36,
                    seed: Math.floor(Math.random() * 1000000)
                });
                
                // Initialiser le fog
                fog.initialize();
                
                // Redessiner
                renderMap();
                
                log('‚úÖ Carte g√©n√©r√©e avec succ√®s', 'success');
                
            } catch (error) {
                log(`‚ùå Erreur g√©n√©ration carte: ${error.message}`, 'error');
            }
        }
        
        // üé≠ INITIALISATION ENTIT√âS
        async function initializeEntities() {
            if (!map.mapData) {
                log('‚ùå G√©n√©rer une carte d\'abord', 'error');
                return;
            }
            
            log('üé≠ Initialisation entit√©s 6D...', 'info');
            
            try {
                await map.initializeEntities([
                    { start: 2, end: 8, period: 12 },
                    { start: 5, end: 15, period: 20 }
                ]);
                
                log('‚úÖ Entit√©s initialis√©es', 'success');
                
            } catch (error) {
                log(`‚ùå Erreur initialisation entit√©s: ${error.message}`, 'error');
            }
        }
        
        // üåÄ TOPOLOGIE NON-EUCLIDIENNE
        function updateTopology(topology) {
            currentTopology = topology;
            
            const descriptions = {
                'plane': 'Plan euclidien standard - g√©om√©trie classique',
                'torus': 'Torus - Les bords se rejoignent (wrap X et Y)',
                'mobius': 'M√∂bius - Wrap horizontal avec inversion verticale',
                'klein': 'Klein - Double wrap/inversion sur X et Y'
            };
            
            const desc = document.getElementById('topologyDesc');
            desc.textContent = descriptions[topology] || 'Topologie inconnue';
            
            // Feedback visuel selon la topologie
            const select = document.getElementById('topologySelect');
            if (topology === 'plane') {
                select.style.borderColor = '#8A2BE2';
            } else if (topology === 'torus') {
                select.style.borderColor = '#FFD700';
            } else if (topology === 'mobius') {
                select.style.borderColor = '#FF1493';
            } else if (topology === 'klein') {
                select.style.borderColor = '#00FF00';
                select.style.boxShadow = '0 0 10px #00FF00';
            }
            
            log(`üåÄ Topologie chang√©e: ${topology}`, 'info');
            
            // üöó Temporal Drift: Enregistrer changement topologie
            if (temporalDrift) {
                temporalDrift.recordTopologyChange();
            }
        }
        
        // üß≠ PATHFINDING AVEC INT√âGRATION VISUELLE
        async function startPathfinding() {
            const selectedPos = document.getElementById('selectedPos').textContent;
            if (selectedPos === 'Aucune') {
                log('‚ùå Cliquer sur position de d√©part d\'abord', 'error');
                return;
            }
            
            const [startX, startY] = selectedPos.split(',').map(n => parseInt(n));
            const goalX = startX + 10;  // Exemple: 10 tiles √† droite
            const goalY = startY + 5;   // Exemple: 5 tiles vers le bas
            
            const start = { x: startX, y: startY, timeline: 'principale' };
            const goal = { x: goalX, y: goalY, timeline: 'principale' };
            
            try {
                const result = await movement.planPath('hero_1', start, goal, {
                    speed_multiplier: 1.0,
                    alpha_causal: 0.7,
                    time_velocity: currentTimeVelocity,  // UTILISE SLIDER
                    topology: currentTopology  // üåÄ UTILISE TOPOLOGIE S√âLECTIONN√âE
                });
                
                if (result.ok) {
                    log(`üß≠ Chemin planifi√©: ${result.path.length} √©tapes, co√ªt: ${result.cost}`, 'success');
                    if (currentTimeVelocity < 0) {
                        log('‚è∞ Mode AXIS: Chemin d\'inversion temporelle', 'info');
                    }
                    if (currentTopology !== 'plane') {
                        log(`üåÄ Topologie ${currentTopology}: G√©om√©trie non-euclidienne active`, 'info');
                    }
                } else {
                    log('‚ùå Impossible de planifier le chemin', 'error');
                }
                
            } catch (error) {
                log(`‚ùå Erreur pathfinding: ${error.message}`, 'error');
            }
        }
        
        // üî¨ INVERSION TEMPORELLE (AXIS)
        function updateTimeVelocity(value) {
            currentTimeVelocity = parseFloat(value);
            const display = document.getElementById('timeVelocityDisplay');
            
            if (currentTimeVelocity < 0) {
                display.textContent = `Vitesse: ${currentTimeVelocity} (‚è™ AXIS)`;
                display.style.color = '#FF4500';
            } else {
                display.textContent = `Vitesse: +${currentTimeVelocity} (Normal)`;
                display.style.color = '#FFD700';
            }
            
            // üöó Temporal Drift: Enregistrer changement vitesse
            if (temporalDrift) {
                temporalDrift.setTimeVelocity(currentTimeVelocity);
            }
        }
        
        function toggleAxisMode() {
            isAxisMode = !isAxisMode;
            const btn = document.getElementById('axisBtn');
            const slider = document.getElementById('timeVelocitySlider');
            
            if (isAxisMode) {
                btn.classList.add('axis-mode');
                btn.textContent = '‚è™ AXIS ON';
                slider.value = '-1.0';
                updateTimeVelocity(-1.0);
            } else {
                btn.classList.remove('axis-mode');
                btn.textContent = 'üîÑ Mode Axis';
                slider.value = '1.0';
                updateTimeVelocity(1.0);
            }
        }
        
        // üëÅÔ∏è OBSERVATION ZONE
        async function observeArea() {
            const selectedPos = document.getElementById('selectedPos').textContent;
            if (selectedPos === 'Aucune') {
                log('‚ùå Cliquer sur une position d\'abord', 'error');
                return;
            }
            
            const [x, y] = selectedPos.split(',').map(n => parseInt(n));
            
            try {
                await fog.observeArea(
                    { x, y, z: 0, t: Date.now() / 1000, c: 0.5, psi: 0 },
                    2,
                    'manual_observation'
                );
                
                renderMap(); // Redessiner avec fog mis √† jour
                log(`üëÅÔ∏è Zone observ√©e en (${x}, ${y})`, 'success');
                
            } catch (error) {
                log(`‚ùå Erreur observation: ${error.message}`, 'error');
            }
        }
        
        // ‚öîÔ∏è R√âSOLUTION CAUSALIT√â
        async function resolveCausality() {
            // Rechercher les collisions via WSG et r√©soudre
            log('üåÄ Recherche de collisions causales...', 'info');
            
            const nodeIds = ['hero_1', 'monster_dragon']; // Exemple
            
            try {
                const response = await fetch('http://localhost:3001/api/causality/resolve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        node_ids: nodeIds,
                        mode: 'QUANTUM',
                        seed: Math.floor(Math.random() * 1000)
                    })
                });
                
                if (!response.ok) throw new Error(`Status: ${response.status}`);
                const result = await response.json();
                
                if (result.started_match_id) {
                    log(`üé¥ Match TCG d√©marr√©: ${result.started_match_id}`, 'info');
                    // Ouvrir interface TCG
                } else if (result.winner) {
                    log(`üèÜ R√©solution quantique: ${result.winner} l'emporte`, 'success');
                }
                
                // üöó Temporal Drift: Enregistrer r√©solution
                if (temporalDrift) {
                    temporalDrift.recordResolve();
                }
                
            } catch (error) {
                log(`‚ùå Erreur r√©solution: ${error.message}`, 'error');
            }
        }
        
        // ‚ú® LANCER SORT (AVEC 'formula')
        async function castSpell(formula) {
            log(`‚ú® Lancement formule: ${formula}`, 'info');
            
            try {
                const response = await fetch('http://localhost:3001/agents/cast', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        formula: formula,
                        formula_type: 'AREA_EFFECT',
                        caster_node_id: selectedEntity?.id || 'player_1',
                        parameters: {
                            target: 'area',
                            power: 50,
                            radius: 3
                        }
                    })
                });
                
                if (!response.ok) throw new Error(`Status: ${response.status}`);
                const result = await response.json();
                
                log(`‚úÖ Formule ${formula} lanc√©e avec succ√®s`, 'success');
                
                // Appliquer effets visuels selon le sort
                if (formula === 'REVEAL_CAUSALITY') {
                    await fog.applyCausalitySpell('REVEAL_CAUSALITY', { x: 10, y: 10, radius: 5 }, 0.8);
                    renderMap();
                }
                
                // üöó Temporal Drift: Enregistrer cast
                if (temporalDrift) {
                    temporalDrift.recordCast();
                }
                
            } catch (error) {
                log(`‚ùå Erreur sort ${formula}: ${error.message}`, 'error');
            }
        }
        
        // üîÑ POLLING WSG
        function startWSGPolling() {
            // Poll WSG toutes les 5 secondes comme conseill√©
            wsgPollInterval = setInterval(pollWorldStateGraph, 5000);
        }
        
        async function pollWorldStateGraph() {
            try {
                const response = await fetch('http://localhost:3001/api/panopticon/world-state-graph');
                
                if (response.ok) {
                    const wsgData = await response.json();
                    updateEntityList(wsgData);
                    document.getElementById('lastWSGPoll').textContent = new Date().toLocaleTimeString();
                } else {
                    log('‚ö†Ô∏è WSG endpoint non disponible', 'error');
                }
                
            } catch (error) {
                // WSG peut ne pas √™tre impl√©ment√© encore
                document.getElementById('lastWSGPoll').textContent = 'API manquante';
            }
        }
        
        // üé® RENDU CARTE
        function renderMap() {
            if (!map.mapData) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const tileWidth = canvas.width / map.config.width;
            const tileHeight = canvas.height / map.config.height;
            
            // Dessiner les biomes
            for (let y = 0; y < map.config.height; y++) {
                for (let x = 0; x < map.config.width; x++) {
                    const tile = map.getTileInfo(x, y);
                    if (!tile) continue;
                    
                    // Couleur selon le biome
                    const biomeColors = {
                        'plain': '#90EE90',
                        'forest': '#228B22', 
                        'mountain': '#8B4513',
                        'sea': '#4169E1'
                    };
                    
                    ctx.fillStyle = biomeColors[tile.biome] || '#666';
                    ctx.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
                    
                    // Obstacles
                    if (tile.obstacle) {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
                    }
                    
                    // Overlay de causalit√©
                    if (fog.getCausalityLevel) {
                        const causalLevel = fog.getCausalityLevel(x, y);
                        if (causalLevel > 0.3) {
                            ctx.fillStyle = `rgba(100,100,100,${causalLevel * 0.7})`;
                            ctx.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
                        }
                    }
                }
            }
            
            // Grille
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= map.config.width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * tileWidth, 0);
                ctx.lineTo(x * tileWidth, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= map.config.height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * tileHeight);
                ctx.lineTo(canvas.width, y * tileHeight);
                ctx.stroke();
            }
        }
        
        // üñ±Ô∏è √âV√âNEMENTS CANVAS
        function setupCanvasEvents() {
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / (canvas.width / map.config.width));
                const y = Math.floor((e.clientY - rect.top) / (canvas.height / map.config.height));
                
                document.getElementById('cursorPos').textContent = `(${x},${y})`;
                
                if (map.mapData) {
                    const causalLevel = fog.getCausalityLevel ? fog.getCausalityLevel(x, y) : 0;
                    document.getElementById('causalityLevel').textContent = causalLevel.toFixed(3);
                }
            });
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / (canvas.width / map.config.width));
                const y = Math.floor((e.clientY - rect.top) / (canvas.height / map.config.height));
                
                document.getElementById('selectedPos').textContent = `${x},${y}`;
                
                log(`üñ±Ô∏è Position s√©lectionn√©e: (${x}, ${y})`, 'info');
                
                // INT√âGRATION QU√äTES - Mettre √† jour position
                if (questSystem) {
                    questSystem.updateLocation(x, y);
                }
                
                // COLLECTE MINI-GAME ou d√©couverte normale
                if (minigames && minigames.getActiveMinigame()?.id === 'herb_collection') {
                    // Mode collecte actif - essayer de r√©colter
                    handleCollectCommand(x, y).catch(error => {
                        log(`üåø ${error.message}`, 'warning');
                    });
                } else if (Math.random() < 0.3) { // 30% chance d√©couverte normale
                    setTimeout(() => {
                        if (questSystem) {
                            questSystem.onItemCollected('time_crystal', 1);
                            if (inventory) {
                                inventory.addResource('time_crystals', 1);
                                updateInventoryUI();
                            }
                        }
                    }, 500);
                }
            });
        }
        
        // üìö OPENAPI VIEWER
        function showOpenAPIViewer() {
            window.open('../API_TESTER.html', '_blank');
        }
        
        // üé¥ CARD GALLERIES
        function openCardGallery() {
            window.open('/DARK_HOLOGRAPHIC_CARDS.html', '_blank');
        }
        
        function openCardComparator() {
            window.open('/CARD_STYLES_COMPARATOR.html', '_blank');
        }
        
        function openArchaeologistBadge() {
            window.open('/BADGE_ARCHEOLOGUE_DU_FUTUR.html', '_blank');
        }

        // üìéüßô CLIPPY-MEMENTO ASSISTANT
        let clippyMemento = null;
        let clippyVisible = false;

        function toggleClippyMemento() {
            if (!clippyMemento) {
                initializeClippyMemento();
            }
            
            clippyVisible = !clippyVisible;
            const clippy = document.getElementById('clippy-memento-game');
            
            if (clippyVisible) {
                clippy.style.display = 'block';
                setTimeout(() => {
                    clippyMemento.showDialogue(
                        "üìéüßô Salut Vincent ! Je suis ton assistant AVALON ! Je peux t'aider avec le lore, les m√©caniques, et la navigation. Que veux-tu savoir ? ‚ú®",
                        ['üó∫Ô∏è Navigation', '‚öîÔ∏è Combat', 'üîÆ Magie', 'üéí Inventaire', 'üìö Lore AVALON']
                    );
                }, 300);
            } else {
                clippyMemento.closeDialogue();
                setTimeout(() => { clippy.style.display = 'none'; }, 300);
            }
        }

        function initializeClippyMemento() {
            // Injecter HTML Clippy
            const clippyHTML = `
            <div id="clippy-memento-game" class="clippy-memento-game" style="display: none;">
                <div class="clippy-body-game">
                    <div class="clippy-shape-game">
                        <div class="clippy-eyes-game">
                            <div class="eye-game"></div>
                            <div class="eye-game"></div>
                        </div>
                    </div>
                    <div class="magic-particles-game">
                        <div class="particle-game"></div>
                        <div class="particle-game"></div>
                        <div class="particle-game"></div>
                    </div>
                </div>
                <div id="clippy-dialogue-game" class="clippy-dialogue-game">
                    <div class="dialogue-header-game">
                        <div class="memento-avatar-game">üìé</div>
                        <div>
                            <strong>Clippy-Memento</strong>
                            <div class="level-indicator">üëë Mode Vincent</div>
                        </div>
                    </div>
                    <div id="dialogue-content-game" class="dialogue-content-game"></div>
                    <div id="dialogue-actions-game" class="dialogue-actions-game"></div>
                </div>
            </div>`;

            document.body.insertAdjacentHTML('beforeend', clippyHTML);

            // Injecter CSS
            const clippyCSS = `
            <style>
            .clippy-memento-game {
                position: fixed;
                right: 20px;
                bottom: 20px;
                z-index: 3000;
                cursor: pointer;
                user-select: none;
            }

            .clippy-body-game {
                width: 70px;
                height: 90px;
                position: relative;
                transition: all 0.3s ease;
            }

            .clippy-shape-game {
                width: 55px;
                height: 70px;
                background: linear-gradient(45deg, #ffd700, #ff6b35, #6366f1);
                border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
                position: relative;
                animation: clippy-idle-game 3s ease-in-out infinite;
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
                cursor: pointer;
            }

            .clippy-eyes-game {
                position: absolute;
                top: 18px;
                left: 15px;
                display: flex;
                gap: 8px;
            }

            .eye-game {
                width: 7px;
                height: 7px;
                background: #1a1a2e;
                border-radius: 50%;
                animation: blink-game 4s infinite;
            }

            .magic-particles-game {
                position: absolute;
                top: -10px;
                left: -10px;
                right: -10px;
                bottom: -10px;
                pointer-events: none;
            }

            .particle-game {
                position: absolute;
                width: 4px;
                height: 4px;
                background: #ffd700;
                border-radius: 50%;
                animation: float-particle-game 2.5s ease-in-out infinite;
            }

            .particle-game:nth-child(1) { top: 15%; left: 25%; animation-delay: 0s; }
            .particle-game:nth-child(2) { top: 35%; right: 20%; animation-delay: 0.8s; }
            .particle-game:nth-child(3) { bottom: 25%; left: 15%; animation-delay: 1.6s; }

            .clippy-dialogue-game {
                position: absolute;
                bottom: 100px;
                right: 0;
                width: 320px;
                background: rgba(26, 26, 46, 0.95);
                border: 2px solid #6366f1;
                border-radius: 15px;
                padding: 18px;
                box-shadow: 0 10px 35px rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(15px);
                transform: scale(0) translateY(20px);
                opacity: 0;
                transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            }

            .clippy-dialogue-game.show {
                transform: scale(1) translateY(0);
                opacity: 1;
            }

            .dialogue-header-game {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid rgba(99, 102, 241, 0.3);
            }

            .memento-avatar-game {
                width: 28px;
                height: 28px;
                background: linear-gradient(45deg, #ffd700, #ff6b35);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
            }

            .level-indicator {
                font-size: 10px;
                color: #ffd700;
                font-weight: bold;
            }

            .dialogue-content-game {
                margin-bottom: 15px;
                line-height: 1.6;
                font-size: 14px;
                color: #e0e0e0;
            }

            .dialogue-actions-game {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .action-btn-game {
                padding: 6px 10px;
                background: rgba(99, 102, 241, 0.2);
                border: 1px solid #6366f1;
                border-radius: 6px;
                color: #a5b4fc;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.2s ease;
            }

            .action-btn-game:hover {
                background: rgba(99, 102, 241, 0.4);
                color: white;
                transform: translateY(-1px);
            }

            @keyframes clippy-idle-game {
                0%, 100% { transform: translateY(0) rotate(0deg); }
                50% { transform: translateY(-4px) rotate(2deg); }
            }

            @keyframes clippy-excited-game {
                0%, 100% { transform: translateY(0) scale(1); }
                25% { transform: translateY(-8px) scale(1.05); }
                75% { transform: translateY(-3px) scale(1.02); }
            }

            @keyframes float-particle-game {
                0%, 100% { opacity: 0; transform: translateY(0) scale(0.8); }
                50% { opacity: 1; transform: translateY(-18px) scale(1.2); }
            }

            @keyframes blink-game {
                0%, 90%, 100% { opacity: 1; }
                95% { opacity: 0; }
            }

            @media (max-width: 768px) {
                .clippy-dialogue-game {
                    width: 280px;
                    right: -30px;
                }
            }
            </style>`;

            document.head.insertAdjacentHTML('beforeend', clippyCSS);

            // Cr√©er objet Clippy-Memento
            clippyMemento = new ClippyMementoGame();
        }

        // Classe Clippy-Memento pour le jeu
        class ClippyMementoGame {
            constructor() {
                this.isDialogueOpen = false;
                this.currentContext = null;
                this.userLevel = 'vincent'; // Vincent = acc√®s total
                
                // Base de connaissances statique (ultra-rapide)
                this.knowledgeBase = {
                    'sid_meier': {
                        message: "üéØ Sid Meier, l'Architecte Paresseux ! Arriv√© dans AVALON via le Portail de Morgana lors de l'√âv√©nement CHEVRON 7. Cr√©ateur l√©gendaire de civilisations, ma√Ætre des hexagones et du calcul probabiliste ! üèõÔ∏è‚ú®",
                        actions: ['üéÆ Ses Capacit√©s', 'üåÄ Portail Morgana', 'üéØ Jouer avec Sid']
                    },
                    'portails': {
                        message: "üåÄ Les Portails d'AVALON ! Tu as 4 types : STANDARD (violet), VORTEX (temporel rose), QUANTUM (turquoise), et DEAD (gris). Morgana contr√¥le le syst√®me principal. Attention, chaque arbre de la For√™t GROFI est un portail potentiel ! üå≤‚ö°",
                        actions: ['üö™ Comment activer', '‚ö†Ô∏è Dangers', 'üó∫Ô∏è Destinations']
                    },
                    'combat': {
                        message: "‚öîÔ∏è Combat AVALON ! Syst√®me TCG automatique quand collision d√©tect√©e. Observe bien les cartes adverses, g√®re ton mana, et utilise les combos ! Le brouillard de causalit√© peut changer la donne ! üÉè‚ö°",
                        actions: ['üé¥ Syst√®me TCG', 'üí° Strat√©gies', 'üîÆ Sorts Combat']
                    },
                    'foret_grofi': {
                        message: "üå≤ For√™t GROFI - ATTENTION ! Cette for√™t est CONSCIENTE et existe dans tous les mondes simultan√©ment ! Chaque arbre est un n≈ìud quantique. La Tour Sombre s'√©l√®ve au centre. Morgana pourrait √äTRE la for√™t ! üîÆ‚ö†Ô∏è",
                        actions: ['üè∞ Tour Sombre', 'üå≥ Arbres Quantiques', 'üëÅÔ∏è Th√©orie Walter']
                    },
                    'vector_db': {
                        message: "üß† Ton Vector DB fonctionne parfaitement ! 5000+ assets index√©s, recherche <10ms, system ultra-optimis√© ! Les IA peuvent chercher dans tout AVALON. Clippy-Memento utilise tes endpoints existants ! üöÄ",
                        actions: ['üìä Voir Stats', 'üîç Test Recherche', '‚öôÔ∏è Performance']
                    }
                };

                this.bindEvents();
            }

            bindEvents() {
                // Click sur Clippy
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.clippy-shape-game')) {
                        if (!this.isDialogueOpen) {
                            this.showWelcomeMessage();
                        }
                    }
                });

                // D√©clencheurs automatiques selon contexte jeu (examples)
                setInterval(() => {
                    this.checkContextualTriggers();
                }, 5000);
            }

            checkContextualTriggers() {
                // √âviter spam si dialogue d√©j√† ouvert
                if (this.isDialogueOpen) return;

                // Exemples de d√©clencheurs selon √©tat du jeu
                if (map && map.currentArea === 'forest_grofi') {
                    this.triggerContextualHelp('foret_grofi');
                } else if (inventory && inventory.items.length >= inventory.maxSlots - 2) {
                    this.triggerContextualHelp('inventory_almost_full');
                }
            }

            triggerContextualHelp(context) {
                // √âviter r√©p√©tition
                if (this.currentContext === context) return;
                this.currentContext = context;

                const knowledge = this.knowledgeBase[context];
                if (knowledge) {
                    this.animateClippy('excited');
                    setTimeout(() => {
                        this.showDialogue(knowledge.message, knowledge.actions);
                    }, 500);
                }
            }

            showWelcomeMessage() {
                this.showDialogue(
                    "üìéüßô Salut Vincent ! Je suis Clippy-Memento, ton assistant personnel d'AVALON ! Je connais tous tes 5000+ assets, l'histoire des portails, les h√©ros, et les syst√®mes techniques. Que veux-tu explorer ? ‚ú®",
                    ['üéØ Sid Meier Info', 'üåÄ Syst√®me Portails', 'üß† Vector DB Status', 'üîÆ Lore Secrets', 'üéÆ Gameplay Help']
                );
            }

            showDialogue(message, actions = []) {
                const dialogue = document.getElementById('clippy-dialogue-game');
                const content = document.getElementById('dialogue-content-game');
                const actionsContainer = document.getElementById('dialogue-actions-game');

                content.innerHTML = message;
                
                // Cr√©er boutons d'action
                actionsContainer.innerHTML = '';
                actions.forEach(action => {
                    const btn = document.createElement('button');
                    btn.className = 'action-btn-game';
                    btn.textContent = action;
                    btn.onclick = () => this.handleAction(action);
                    actionsContainer.appendChild(btn);
                });

                // Bouton fermer
                const closeBtn = document.createElement('button');
                closeBtn.className = 'action-btn-game';
                closeBtn.textContent = '‚ùå Fermer';
                closeBtn.onclick = () => this.closeDialogue();
                actionsContainer.appendChild(closeBtn);

                dialogue.classList.add('show');
                this.isDialogueOpen = true;
            }

            handleAction(action) {
                if (action.includes('Sid Meier')) {
                    this.showDialogue(this.knowledgeBase.sid_meier.message, this.knowledgeBase.sid_meier.actions);
                } else if (action.includes('Portails')) {
                    this.showDialogue(this.knowledgeBase.portails.message, this.knowledgeBase.portails.actions);
                } else if (action.includes('Combat')) {
                    this.showDialogue(this.knowledgeBase.combat.message, this.knowledgeBase.combat.actions);
                } else if (action.includes('Vector DB')) {
                    this.showDialogue(this.knowledgeBase.vector_db.message, this.knowledgeBase.vector_db.actions);
                } else if (action.includes('Lore Secrets')) {
                    this.showDialogue("üîÆ Acc√®s Vincent aux secrets ! Tu as acc√®s √† TOUT : archives niveau 5, portails Morgana, syst√®mes techniques, lore complet ! Que veux-tu explorer ? üëë‚ö°", ['üåÄ Portails Secrets', 'üè∞ Tour Sombre', 'üìö Archives Priv√©es']);
                } else if (action.includes('Gameplay')) {
                    this.showDialogue("üéÆ Gameplay AVALON ! Exploration 6D + TCG combat + craft + qu√™tes temporelles ! Syst√®me de drift pour r√©guler vitesse. Progression XP automatique ! ‚ö°üéØ", ['‚öîÔ∏è Combat TCG', 'üéí Syst√®me Craft', '‚è∞ Temporal Drift']);
                } else {
                    this.showDialogue(`üìé "${action}" - Fonctionnalit√© disponible ! En mode Vincent, tu as acc√®s √† toutes les informations. Cette action sera bient√¥t connect√©e √† ton Vector DB pour des r√©ponses encore plus pr√©cises ! üöÄ`, []);
                }
            }

            closeDialogue() {
                document.getElementById('clippy-dialogue-game').classList.remove('show');
                this.isDialogueOpen = false;
                this.currentContext = null;
            }

            animateClippy(type) {
                const clippy = document.querySelector('.clippy-shape-game');
                if (!clippy) return;
                
                const animations = {
                    'excited': 'clippy-excited-game 1s ease-in-out',
                    'thinking': 'clippy-thinking-game 1s ease-in-out',
                    'idle': 'clippy-idle-game 3s ease-in-out infinite'
                };
                
                clippy.style.animation = animations[type] || animations.idle;
                
                if (type !== 'idle') {
                    setTimeout(() => {
                        clippy.style.animation = animations.idle;
                    }, 1000);
                }
            }
        }
        
        // üßπ UTILITAIRES
        function log(message, type = 'info') {
            const logArea = document.getElementById('debugLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }
        
        function clearAll() {
            document.getElementById('debugLog').innerHTML = '';
            document.getElementById('entityList').innerHTML = '<div class="entity-item">Aucune entit√© d√©tect√©e</div>';
            selectedEntity = null;
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function updateEntityList(wsgData) {
            // Mettre √† jour la liste des entit√©s depuis WSG
            // Implementation selon les donn√©es re√ßues
        }
        
        function drawPath(path, timeVelocity = 1.0) {
            if (!path || path.length < 2) return;
            
            const tileWidth = canvas.width / map.config.width;
            const tileHeight = canvas.height / map.config.height;
            
            // COULEUR SELON TIME_VELOCITY
            if (timeVelocity < 0) {
                ctx.strokeStyle = '#FF4500';  // Orange pour AXIS
                ctx.lineWidth = 4;
                ctx.setLineDash([3, 3]);
            } else if (timeVelocity > 1.0) {
                ctx.strokeStyle = '#00FF00';  // Vert pour vitesse √©lev√©e
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 2]);
            } else {
                ctx.strokeStyle = '#FFD700';  // Or pour normal
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
            }
            
            // TRACER LE CHEMIN
            ctx.beginPath();
            for (let i = 0; i < path.length; i++) {
                const point = path[i];
                const pixelX = (point.x + 0.5) * tileWidth;
                const pixelY = (point.y + 0.5) * tileHeight;
                
                if (i === 0) {
                    ctx.moveTo(pixelX, pixelY);
                    // Marqueur d√©but (carr√©)
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.fillRect(pixelX - 3, pixelY - 3, 6, 6);
                } else {
                    ctx.lineTo(pixelX, pixelY);
                }
                
                // Marqueur fin (cercle)
                if (i === path.length - 1) {
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.beginPath();
                    ctx.arc(pixelX, pixelY, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo((path[0].x + 0.5) * tileWidth, (path[0].y + 0.5) * tileHeight);
                    for (let j = 1; j < path.length; j++) {
                        ctx.lineTo((path[j].x + 0.5) * tileWidth, (path[j].y + 0.5) * tileHeight);
                    }
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function setupEventCallbacks() {
            // Callbacks selon les conseils du coll√®gue
            if (movement) {
                // NOUVEAU: Tra√ßage visuel du chemin planifi√©
                movement.onPathPlanned = (agentId, path, timeVelocity) => {
                    drawPath(path, timeVelocity);
                    log(`üó∫Ô∏è Route trac√©e pour ${agentId}: ${path.length} √©tapes (velocity: ${timeVelocity})`, 'success');
                };
                
                movement.onMoveEnd = (agentId, position, duration) => {
                    log(`üèÅ ${agentId} arriv√© en (${position.x}, ${position.y}) en ${duration}ms`, 'success');
                    
                    // SYNCHRONISATION BROUILLARD apr√®s mouvement
                    if (fog && fog.markObserved) {
                        fog.markObserved(position.x, position.y, 2);
                        renderMap(); // Redessiner avec fog mis √† jour
                    }
                    
                    // üöó Temporal Drift: Enregistrer mouvement termin√©
                    if (temporalDrift) {
                        temporalDrift.recordMove();
                    }
                };
                
                movement.onCollisionDetected = (agentId, others, position) => {
                    log(`‚öîÔ∏è Collision d√©tect√©e: ${agentId} vs ${others.join(', ')} en (${position.x}, ${position.y})`, 'info');
                };
                
                movement.onTimeInversion = (agentId, path) => {
                    log(`‚è∞ Inversion temporelle activ√©e pour ${agentId}`, 'info');
                };
                
                movement.onMoveWithFog = (agentId, position, fogResult) => {
                    log(`üö∂ ${agentId} r√©v√®le ${fogResult.newTilesCount} nouvelles zones en (${position.x}, ${position.y})`, 'success');
                    
                    // Effets visuels pour exploration majeure
                    if (fogResult.newTilesCount >= 5) {
                        log('üéâ Grande d√©couverte! Zone importante r√©v√©l√©e', 'success');
                        
                        // R√©compense pour exploration
                        if (inventory) {
                            inventory.addResource('gold', 25);
                            log('üí∞ +25 gold pour exploration', 'success');
                        }
                    }
                };
            }
            
            if (fog) {
                fog.onTileExplored = (tilesRevealed, context) => {
                    if (Array.isArray(tilesRevealed)) {
                        log(`üîç ${tilesRevealed.length} tiles explor√©es autour de (${context.centerX}, ${context.centerY})`, 'info');
                        renderMap(); // Redessiner avec nouvelles zones r√©v√©l√©es
                    } else {
                        // Ancien format (compatibilit√©)
                        log(`üîç Tile (${tilesRevealed}, ${context}) explor√©e`, 'info');
                    }
                };
                
                fog.onAreaObserved = (center, radius, result) => {
                    log(`üëÅÔ∏è Observation collapse en (${center.x}, ${center.y}), rayon: ${radius}`, 'success');
                    renderMap(); // Redessiner apr√®s collapse
                };
                
                // Alias pour compatibilit√©
                fog.onObservationCollapse = fog.onAreaObserved;
            }
        }
        
        // üö∂ D√âMARRER MOUVEMENT AVEC SYNCHRONISATION
        async function startMovement() {
            const selectedPos = document.getElementById('selectedPos').textContent;
            if (selectedPos === 'Aucune') {
                log('‚ùå Cliquer sur position de d√©part d\'abord', 'error');
                return;
            }
            
            // D'abord planifier le chemin
            await startPathfinding();
            
            // Puis d√©marrer le mouvement simul√©
            const [startX, startY] = selectedPos.split(',').map(n => parseInt(n));
            const path = [
                { x: startX, y: startY },
                { x: startX + 2, y: startY + 1 },
                { x: startX + 4, y: startY + 2 },
                { x: startX + 6, y: startY + 3 }
            ];
            
            try {
                await movement.startMovement('hero_1', path, 800); // 800ms par step
                log('üö∂ Mouvement d√©marr√© avec synchronisation fog', 'success');
                
                // üöó Temporal Drift: Enregistrer mouvement
                if (temporalDrift) {
                    temporalDrift.recordMove();
                }
            } catch (error) {
                log(`‚ùå Erreur mouvement: ${error.message}`, 'error');
            }
        }
        
        // üåÄ TEST TOPOLOGIES NON-EUCLIDIENNES
        async function testTopologies() {
            log('üß™ Test de toutes les topologies non-euclidiennes...', 'info');
            
            const topologies = ['plane', 'torus', 'mobius', 'klein'];
            const originalTopology = currentTopology;
            
            if (!map.mapData) {
                await generateNewMap();
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            for (const topology of topologies) {
                log(`üåÄ Test topologie: ${topology}`, 'info');
                
                // Changer la topologie
                updateTopology(topology);
                document.getElementById('topologySelect').value = topology;
                
                // Tester un chemin avec cette topologie
                const start = { x: 5, y: 5, timeline: 'principale' };
                const goal = { x: 40, y: 30, timeline: 'principale' }; // Goal pr√®s du bord pour tester wrap
                
                try {
                    const result = await movement.planPath(`test_${topology}`, start, goal, {
                        speed_multiplier: 1.0,
                        alpha_causal: 0.5,
                        time_velocity: 1.0,
                        topology: topology
                    });
                    
                    if (result.ok) {
                        log(`‚úÖ ${topology}: ${result.path.length} √©tapes, co√ªt: ${result.cost}`, 'success');
                        
                        // Analyses sp√©cifiques par topologie
                        if (topology === 'torus' && result.path.length > 0) {
                            log(`üç© Torus: Chemin peut wrapper les bords`, 'info');
                        } else if (topology === 'mobius' && result.path.length > 0) {
                            log(`‚ôæÔ∏è M√∂bius: Inversion verticale possible`, 'info');
                        } else if (topology === 'klein' && result.path.length > 0) {
                            log(`üåÄ Klein: Double wrap/inversion active`, 'info');
                        }
                    } else {
                        log(`‚ùå ${topology}: Pathfinding √©chou√©`, 'error');
                    }
                    
                } catch (error) {
                    log(`‚ùå ${topology}: ${error.message}`, 'error');
                }
                
                await new Promise(resolve => setTimeout(resolve, 300)); // Pause entre tests
            }
            
            // Remettre la topologie originale
            updateTopology(originalTopology);
            document.getElementById('topologySelect').value = originalTopology;
            
            log('üéâ Test de toutes les topologies termin√©!', 'success');
        }
        
        // üéí SYST√àME INVENTAIRE ET HOTBAR
        function setupInventoryCallbacks() {
            if (!inventory) return;
            
            // Callback item utilis√©
            inventory.onItemUsed = (itemId, item, result) => {
                log(`üéí ${item.name} utilis√©`, 'success');
                updateInventoryUI();
                
                // Effets sp√©ciaux selon l'item
                if (item.effects?.includes('reveal_causality') && fog) {
                    const center = { x: 24, y: 18, z: 0, t: Date.now()/1000, c: 0.5, psi: 0 };
                    fog.observeArea(center, item.power || 2, 'item_reveal');
                }
            };
            
            // Callback sort lanc√©
            inventory.onSpellCast = (spellId, spell, result) => {
                log(`‚ú® ${spell.name} lanc√©`, 'success');
                updateInventoryUI();
                
                // Effets visuels
                if (spell.effects?.includes('temporal_sight')) {
                    log('üëÅÔ∏è Traces temporelles r√©v√©l√©es...', 'info');
                } else if (spell.effects?.includes('phase_through')) {
                    log('üëª D√©phasage temporaire activ√©', 'info');
                }
            };
            
            // Callback ressources chang√©es
            inventory.onResourceChanged = (type, newValue) => {
                updateResourceDisplay(type, newValue);
            };
            
            // Callback inventaire mis √† jour
            inventory.onInventoryUpdated = (action, id, data) => {
                updateInventoryUI();
                if (action === 'hotbar_updated') {
                    updateHotbarUI();
                }
            };
        }
        
        function updateInventoryUI() {
            if (!inventory) return;
            
            // Mettre √† jour les ressources
            updateResourceDisplay('gold', inventory.resources.gold);
            updateResourceDisplay('mana', inventory.resources.mana);
            updateResourceDisplay('time_crystals', inventory.resources.time_crystals);
            
            // Mettre √† jour la hotbar
            updateHotbarUI();
            
            // Mettre √† jour les artefacts √©quip√©s
            updateArtifactsDisplay();
        }
        
        function updateResourceDisplay(type, value) {
            const displayMap = {
                'gold': 'goldCount',
                'mana': 'manaCount', 
                'time_crystals': 'crystalCount'
            };
            
            const elementId = displayMap[type];
            if (elementId) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = value;
                }
            }
        }
        
        function updateHotbarUI() {
            if (!inventory) return;
            
            for (let i = 0; i < inventory.hotbarSlots; i++) {
                const slot = document.getElementById(`slot${i}`);
                const hotbarItem = inventory.hotbar[i];
                
                if (!slot) continue;
                
                slot.className = 'hotbar-slot';
                slot.innerHTML = i + 1; // Num√©ro par d√©faut
                
                if (hotbarItem) {
                    slot.classList.add('has-item');
                    
                    let item = null;
                    let icon = '‚ùì';
                    let name = 'Inconnu';
                    
                    if (hotbarItem.type === 'item') {
                        item = inventory.items.get(hotbarItem.id);
                        if (item) {
                            icon = getItemIcon(item);
                            name = item.name;
                        }
                    } else if (hotbarItem.type === 'spell') {
                        item = inventory.spells.get(hotbarItem.id);
                        if (item) {
                            icon = getSpellIcon(item);
                            name = item.name;
                        }
                    }
                    
                    slot.innerHTML = `<div class="item-icon">${icon}</div>`;
                    slot.title = name;
                    
                    // V√©rifier cooldown
                    if (item && isOnCooldown(item)) {
                        slot.classList.add('cooldown');
                        const remaining = getCooldownRemaining(item);
                        slot.innerHTML += `<div class="cooldown-overlay">${remaining}s</div>`;
                    }
                }
            }
        }
        
        function getItemIcon(item) {
            const iconMap = {
                'health_potion': '‚ù§Ô∏è',
                'mana_crystal': 'üíô', 
                'time_lens': 'üîç',
                'wiener_eye_fragment': 'üëÅÔ∏è'
            };
            return iconMap[item.id] || 'üì¶';
        }
        
        function getSpellIcon(spell) {
            const iconMap = {
                'echo_temporel': 'üîÆ',
                'phase_shift': 'üëª',
                'reveal_causality': 'üëÅÔ∏è',
                'chaos_fog': 'üå™Ô∏è',
                'time_clarity': '‚è∞'
            };
            return iconMap[spell.id] || '‚ú®';
        }
        
        function isOnCooldown(item) {
            if (!item.lastUsed && !item.lastCast) return false;
            
            const lastUse = item.lastUsed || item.lastCast || 0;
            const cooldown = item.cooldown || 0;
            const now = Date.now();
            
            return (now - lastUse) < cooldown;
        }
        
        function getCooldownRemaining(item) {
            const lastUse = item.lastUsed || item.lastCast || 0;
            const cooldown = item.cooldown || 0;
            const now = Date.now();
            
            return Math.ceil((cooldown - (now - lastUse)) / 1000);
        }
        
        function updateArtifactsDisplay() {
            const artifactsList = document.getElementById('artifactsList');
            if (!artifactsList || !inventory) return;
            
            const equipped = inventory.getEquippedArtifacts();
            
            if (equipped.length === 0) {
                artifactsList.textContent = 'Aucun artefact √©quip√©';
                return;
            }
            
            const html = equipped.map(artifact => {
                const rarity = artifact.rarity || 'common';
                const color = getRarityColor(rarity);
                return `<div style="color: ${color}; margin: 2px 0;">${artifact.name}</div>`;
            }).join('');
            
            artifactsList.innerHTML = html;
        }
        
        function getRarityColor(rarity) {
            const colors = {
                'common': '#aaa',
                'rare': '#4169E1',
                'epic': '#8A2BE2',
                'legendary': '#FFD700'
            };
            return colors[rarity] || '#aaa';
        }
        
        // üéÆ ACTIONS HOTBAR
        async function useHotbarSlot(slotIndex) {
            if (!inventory) {
                log('‚ùå Inventaire non initialis√©', 'error');
                return;
            }
            
            try {
                const result = await inventory.useHotbarSlot(slotIndex);
                updateInventoryUI();
                
                log(`‚ö° Slot ${slotIndex + 1} utilis√©`, 'success');
                
            } catch (error) {
                log(`‚ùå Slot ${slotIndex + 1}: ${error.message}`, 'error');
            }
        }
        
        async function autoHeal() {
            if (!inventory) return;
            
            try {
                await inventory.useItem('health_potion');
                log('‚ù§Ô∏è Auto-heal d√©clench√©', 'success');
                
            } catch (error) {
                log(`‚ùå Auto-heal: ${error.message}`, 'error');
            }
        }
        
        function openInventory() {
            // TODO: Ouvrir panneau inventaire complet
            log('üì¶ Inventaire complet - √Ä impl√©menter', 'info');
            
            // Pour l'instant, afficher un r√©sum√©
            if (inventory) {
                log(`Items: ${inventory.items.size}, Sorts: ${inventory.spells.size}, Artefacts: ${inventory.artifacts.size}`, 'info');
            }
        }
        
        // ‚å®Ô∏è RACCOURCIS CLAVIER HOTBAR
        document.addEventListener('keydown', function(event) {
            // Touches 1-8 pour hotbar
            if (event.key >= '1' && event.key <= '8') {
                const slotIndex = parseInt(event.key) - 1;
                useHotbarSlot(slotIndex);
                event.preventDefault();
            }
            
            // Touche H pour auto-heal
            if (event.key.toLowerCase() === 'h') {
                autoHeal();
                event.preventDefault();
            }
            
            // Touche I pour inventaire
            if (event.key.toLowerCase() === 'i') {
                openInventory();
                event.preventDefault();
            }
        });
        
        // üåê SYST√àME WSG ET COLLISIONS
        function setupWSGCallbacks() {
            if (!wsg) return;
            
            // Callback entit√© d√©couverte
            wsg.onEntityDiscovered = (nodeId, entity) => {
                log(`üé≠ Entit√© d√©couverte: ${entity.identity} (${entity.type})`, 'info');
                renderMap(); // Redessiner avec nouvelles entit√©s
            };
            
            // Callback entit√© d√©plac√©e
            wsg.onEntityMoved = (nodeId, entity, previous) => {
                log(`üö∂ ${entity.identity} d√©plac√©: (${previous.x},${previous.y}) ‚Üí (${entity.x},${entity.y})`, 'info');
                renderMap();
            };
            
            // Callback collision d√©tect√©e
            wsg.onCollisionDetected = (entity1, entity2, distance) => {
                log(`‚öîÔ∏è COLLISION: ${entity1.identity} vs ${entity2.identity} (d=${distance.toFixed(2)})`, 'warning');
                
                // Effet visuel collision
                flashCollisionEffect(entity1, entity2);
            };
            
            // Callback TCG d√©clench√©
            wsg.onTCGTriggered = (matchId, entity1, entity2, result) => {
                log(`üÉè TCG D√âCLENCH√â: Match ${matchId}`, 'success');
                openTCGPanel(matchId, entity1, entity2, result);
            };
            
            // Callback r√©solution compl√®te
            wsg.onResolutionComplete = (winner, entity1, entity2, result) => {
                log(`üëë R√âSOLUTION: Vainqueur ${winner}`, 'success');
                handleResolutionResult(winner, entity1, entity2, result);
            };
            
            // Callback erreur WSG
            wsg.onWSGError = (errorType, error) => {
                log(`‚ùå WSG Error (${errorType}): ${error.message}`, 'error');
            };
        }
        
        function flashCollisionEffect(entity1, entity2) {
            // Effet visuel temporaire sur le canvas
            if (!canvas || !ctx) return;
            
            const tileWidth = canvas.width / map.config.width;
            const tileHeight = canvas.height / map.config.height;
            
            // Flash rouge aux positions des entit√©s
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = '#FF4500';
            
            // Entity 1
            ctx.fillRect(
                entity1.x * tileWidth - 2,
                entity1.y * tileHeight - 2,
                tileWidth + 4,
                tileHeight + 4
            );
            
            // Entity 2
            ctx.fillRect(
                entity2.x * tileWidth - 2,
                entity2.y * tileHeight - 2,
                tileWidth + 4,
                tileHeight + 4
            );
            
            ctx.restore();
            
            // Restaurer apr√®s 300ms
            setTimeout(() => {
                renderMap();
            }, 300);
        }
        
        function openTCGPanel(matchId, entity1, entity2, result) {
            log(`üÉè Ouverture TCG Panel - Match: ${matchId}`, 'info');
            
            // Configurer callbacks TCG
            setupTCGCallbacks();
            
            // Ouvrir le vrai panneau TCG
            if (window.tcgPanel) {
                window.tcgPanel.open(matchId, entity1, entity2, result);
            }
        }
        
        function setupTCGCallbacks() {
            if (!window.tcgPanel) return;
            
            // Callback d√©but de match
            window.tcgPanel.onMatchStart = (matchId, playerEntity, enemyEntity) => {
                log(`‚öîÔ∏è Combat d√©marr√©: ${playerEntity.identity} vs ${enemyEntity.identity}`, 'success');
                
                // Pause WSG pendant le combat
                if (wsg) {
                    wsg.stop();
                }
            };
            
            // Callback fin de match
            window.tcgPanel.onMatchEnd = (matchId, winner, playerEntity, enemyEntity) => {
                log(`üèÜ Combat termin√© - Vainqueur: ${winner}`, 'success');
                
                // Reprendre WSG apr√®s combat
                if (wsg) {
                    wsg.start();
                }
                
                // Gestion post-combat
                handleTCGResult(matchId, winner, playerEntity, enemyEntity);
            };
            
            // Callback carte jou√©e
            window.tcgPanel.onCardPlayed = (card, player) => {
                log(`üÉè ${player} joue ${card.name}`, 'info');
            };
        }
        
        function handleTCGResult(matchId, winner, playerEntity, enemyEntity) {
            const playerWon = winner === playerEntity.node_id;
            
            if (playerWon) {
                log('üéâ Victoire du joueur!', 'success');
                
                // R√©compenses de victoire
                if (inventory) {
                    inventory.addResource('gold', 100);
                    inventory.addResource('time_crystals', 2);
                    
                    // Bonus selon type d'ennemi
                    if (enemyEntity.type === 'treasure') {
                        inventory.addResource('gold', 150);
                        log('üí∞ Tr√©sor suppl√©mentaire d√©couvert!', 'success');
                    } else if (enemyEntity.hostile) {
                        inventory.addResource('time_crystals', 3);
                        log('‚è≥ Cristaux temporels de combat obtenus!', 'success');
                    }
                }
                
                // Effet visuel victoire
                setTimeout(() => {
                    log('‚ú® Exp√©rience gagn√©e! Nouvelles capacit√©s d√©bloqu√©es', 'success');
                }, 1000);
                
            } else {
                log('üíÄ D√©faite du joueur...', 'warning');
                
                // P√©nalit√©s de d√©faite
                if (inventory) {
                    const goldLoss = Math.min(50, inventory.resources.gold);
                    inventory.resources.gold -= goldLoss;
                    
                    if (goldLoss > 0) {
                        log(`üí∏ Vous perdez ${goldLoss} gold`, 'warning');
                    }
                }
                
                // Effet visuel d√©faite
                setTimeout(() => {
                    log('üîÑ Respawn dans 3 secondes...', 'info');
                    // TODO: Respawn logic
                }, 1000);
            }
            
            // Mettre √† jour l'UI
            if (inventory) {
                updateInventoryUI();
            }
            
            renderMap();
        }
        
        function handleResolutionResult(winner, entity1, entity2, result) {
            // Gestion r√©solution automatique (QUANTUM)
            if (wsg && wsg.localPlayer && winner === wsg.localPlayer.node_id) {
                log('‚ú® R√©solution favorable!', 'success');
                
                // R√©compense basique
                if (inventory && entity2.type === 'treasure') {
                    inventory.addResource('gold', 50);
                    inventory.addResource('time_crystals', 1);
                    log('üí∞ Tr√©sor obtenu: +50 gold, +1 cristal temporel', 'success');
                }
            } else {
                log('‚ö° R√©solution d√©favorable', 'warning');
            }
            
            renderMap();
        }
        
        // üéÆ CONTR√îLES WSG
        function toggleWSG() {
            if (!wsg) return;
            
            if (wsg.enabled) {
                wsg.stop();
                log('üåê WSG arr√™t√©', 'info');
            } else {
                wsg.start();
                log('üåê WSG d√©marr√©', 'success');
            }
        }
        
        function forceCollisionCheck() {
            if (!wsg) return;
            
            wsg.forceCollisionCheck();
            log('üîç V√©rification collision forc√©e', 'info');
        }
        
        function showWSGStatus() {
            if (!wsg) return;
            
            const status = wsg.getStatus();
            log(`üìä WSG Status: ${status.entityCount} entit√©s, polling ${status.enabled ? 'ON' : 'OFF'}`, 'info');
            
            if (status.playerPosition) {
                log(`üë§ Joueur: (${status.playerPosition.x}, ${status.playerPosition.y})`, 'info');
            }
        }
        
        function setProximityRadius(radius) {
            if (!wsg) return;
            
            wsg.setProximityRadius(parseFloat(radius));
            log(`üéØ Rayon de proximit√©: ${radius}`, 'info');
            
            // Mettre √† jour l'affichage
            updateWSGDisplay();
        }
        
        function updateWSGDisplay() {
            if (!wsg) return;
            
            const status = wsg.getStatus();
            
            // Mettre √† jour les √©l√©ments UI
            const statusElement = document.getElementById('wsgStatus');
            const entityCountElement = document.getElementById('entityCount');
            const collisionCountElement = document.getElementById('collisionCount');
            const proximityRadiusElement = document.getElementById('proximityRadius');
            
            if (statusElement) {
                statusElement.textContent = status.enabled ? 'Actif' : 'Arr√™t√©';
                statusElement.style.color = status.enabled ? '#00FF00' : '#FF4500';
            }
            
            if (entityCountElement) {
                entityCountElement.textContent = status.entityCount;
            }
            
            if (collisionCountElement) {
                collisionCountElement.textContent = status.detectedCollisions;
            }
            
            if (proximityRadiusElement) {
                proximityRadiusElement.textContent = wsg.proximityRadius.toFixed(1);
            }
        }
        
        // Mettre √† jour l'affichage WSG toutes les 3 secondes
        setInterval(updateWSGDisplay, 3000);
        
        // üéØ SYST√àME DE QU√äTES
        function setupQuestCallbacks() {
            if (!questSystem) return;
            
            // Callback qu√™te d√©marr√©e
            questSystem.onQuestStarted = (questId, questData) => {
                log(`üéØ Nouvelle qu√™te: ${questData.name}`, 'success');
                updateQuestUI();
                
                // Notification sp√©ciale pour qu√™tes principales
                if (questData.type === 'main') {
                    log(`üìú ${questData.description}`, 'info');
                }
            };
            
            // Callback qu√™te compl√©t√©e
            questSystem.onQuestCompleted = (questId, questData) => {
                log(`üèÜ QU√äTE COMPL√âT√âE: ${questData.name}`, 'success');
                
                // Effets visuels de c√©l√©bration
                setTimeout(() => {
                    log('‚ú® R√©compenses re√ßues!', 'success');
                }, 500);
                
                updateQuestUI();
                updateInventoryUI(); // Pour les r√©compenses
            };
            
            // Callback objectif compl√©t√©
            questSystem.onObjectiveCompleted = (questId, objectiveId, objective) => {
                log(`‚úÖ ${objective.description}`, 'success');
                updateQuestUI();
            };
            
            // Callback changement de lieu
            questSystem.onLocationChanged = (newLocation, oldLocation, locationData) => {
                log(`üìç ${locationData.name}`, 'info');
                log(`${locationData.description}`, 'info');
                updateLocationDisplay(locationData);
                updateQuestUI();
            };
            
            // Callback progression
            questSystem.onProgressUpdate = (questId, objectiveId, objective) => {
                updateQuestUI();
            };
        }
        
        function updateQuestUI() {
            if (!questSystem) return;
            
            const questList = document.getElementById('questList');
            if (!questList) return;
            
            const activeQuests = questSystem.getActiveQuests();
            
            if (activeQuests.length === 0) {
                questList.innerHTML = '<div style="color: #666;">Aucune qu√™te active</div>';
                return;
            }
            
            let html = '';
            
            for (const quest of activeQuests) {
                const typeIcon = quest.type === 'main' ? '‚≠ê' : 'üìã';
                const completedObjectives = quest.objectives.filter(obj => obj.completed).length;
                const totalObjectives = quest.objectives.length;
                
                html += `
                    <div style="margin-bottom: 8px; padding: 5px; background: rgba(255,255,255,0.05); border-radius: 3px;">
                        <div style="color: #FFD700; font-weight: bold; font-size: 11px;">
                            ${typeIcon} ${quest.name}
                        </div>
                        <div style="color: #ccc; font-size: 9px; margin-top: 2px;">
                            ${completedObjectives}/${totalObjectives} objectifs
                        </div>
                        <div style="width: 100%; height: 3px; background: #333; border-radius: 2px; margin-top: 3px;">
                            <div style="width: ${(completedObjectives/totalObjectives)*100}%; height: 100%; background: #8A2BE2; border-radius: 2px;"></div>
                        </div>
                    </div>
                `;
            }
            
            questList.innerHTML = html;
        }
        
        function updateLocationDisplay(locationData) {
            const nameElement = document.getElementById('currentLocationName');
            const descElement = document.getElementById('currentLocationDesc');
            
            if (nameElement) {
                nameElement.textContent = locationData.name;
            }
            
            if (descElement) {
                descElement.textContent = locationData.description;
            }
        }
        
        function showQuestLog() {
            if (!questSystem) return;
            
            log('üìú === JOURNAL DE QU√äTES ===', 'info');
            
            const mainQuests = questSystem.getMainQuestLine();
            
            log('üåü QU√äTES PRINCIPALES:', 'info');
            for (const questInfo of mainQuests) {
                const statusIcon = questInfo.status === 'completed' ? '‚úÖ' : 
                                  questInfo.status === 'active' ? 'üéØ' : 'üîí';
                log(`${statusIcon} ${questInfo.quest.name} (${questInfo.status})`, 'info');
                
                if (questInfo.status === 'active') {
                    const quest = questSystem.activeQuests.get(questInfo.id);
                    if (quest) {
                        for (const objective of quest.objectives) {
                            const objIcon = objective.completed ? '‚úÖ' : 'üìã';
                            log(`  ${objIcon} ${objective.description}`, 'info');
                        }
                    }
                }
            }
            
            const currentLocation = questSystem.getCurrentLocationInfo();
            if (currentLocation) {
                log(`üìç Localisation actuelle: ${currentLocation.name}`, 'info');
            }
        }
        
        // üó∫Ô∏è INT√âGRATION QU√äTES AVEC MOUVEMENT
        function updateQuestSystemOnMove(x, y) {
            if (questSystem) {
                questSystem.updateLocation(x, y);
            }
        }
        

        
        // üÉè TEST TCG
        function testTCG() {
            log('üÉè Test du panneau TCG...', 'info');
            
            // Cr√©er entit√©s de test
            const playerEntity = {
                node_id: 'test_player',
                identity: 'Hero Temporel',
                type: 'hero',
                x: 10, y: 10, z: 0,
                t: Date.now() / 1000,
                c: 0.5, psi: 0
            };
            
            const enemyEntity = {
                node_id: 'test_enemy',
                identity: 'Gardien Causal',
                type: 'npc',
                x: 11, y: 10, z: 0,
                t: Date.now() / 1000,
                c: 0.3, psi: 0.2,
                hostile: true
            };
            
            const mockResult = {
                mode: 'TCG',
                started_match_id: 'test_match_' + Date.now(),
                involved: [playerEntity.node_id, enemyEntity.node_id]
            };
            
            // D√©clencher le TCG
            openTCGPanel(mockResult.started_match_id, playerEntity, enemyEntity, mockResult);
        }
        
        // üéÆ SYST√àME MINI-GAMES
        function setupMinigameCallbacks() {
            if (!minigames) return;
            
            // Callback d√©marrage mini-game
            minigames.onMinigameStart = (minigameId, minigameData) => {
                log(`üéÆ Mini-game d√©marr√©: ${minigameData.name}`, 'success');
                updateMinigameUI();
                
                // Affichage sp√©cial selon le type
                if (minigameId === 'panoramix_potions') {
                    log('üßô‚Äç‚ôÇÔ∏è Panoramix: "Bienvenue dans mon atelier, apprenti ! Cr√©ons de la magie !"', 'info');
                } else if (minigameId === 'senku_chemistry') {
                    log('üß™ Senku: "Get excited ! 10 milliards % que √ßa va √™tre scientifique !"', 'info');
                } else if (minigameId === 'herb_collection') {
                    log('üåø Syst√®me de collecte activ√© - Explorez pour trouver des herbes rares', 'info');
                }
            };
            
            // Callback fin mini-game
            minigames.onMinigameComplete = (minigameId, minigameData) => {
                log(`üèÜ Mini-game termin√©: ${minigameData.name}`, 'success');
                updateMinigameUI();
            };
            
            // Callback ressource r√©colt√©e
            minigames.onResourceGathered = (resource, quantity, resourceDef, biome) => {
                log(`üåø Collect√©: ${quantity}x ${resourceDef.name} (${biome})`, 'success');
                updateInventoryUI();
                
                // Chance d'interaction avec personnages
                if (Math.random() < 0.3) {
                    const comments = [
                        `üßô‚Äç‚ôÇÔ∏è Panoramix: "Excellente ${resourceDef.name} ! Parfaite pour mes potions !"`,
                        `üß™ Senku: "Sp√©cimen int√©ressant ! Analysons sa composition chimique !"`,
                        `üåø Guide: "Cette ${resourceDef.name} est rare dans ce biome !"`
                    ];
                    const comment = comments[Math.floor(Math.random() * comments.length)];
                    setTimeout(() => log(comment, 'info'), 1000);
                }
            };
            
            // Callback recette cr√©√©e
            minigames.onRecipeCrafted = (minigameType, recipeId, recipeData) => {
                log(`‚ú® Recette cr√©√©e: ${recipeData.name}`, 'success');
                updateInventoryUI();
                
                if (minigameType === 'panoramix_potions' && recipeData.runes) {
                    log(`üìú Runes utilis√©es: ${recipeData.runes}`, 'info');
                } else if (minigameType === 'senku_chemistry' && recipeData.formula) {
                    log(`‚öóÔ∏è Formule: ${recipeData.formula}`, 'info');
                }
            };
            
            // Callback level up skill
            minigames.onSkillLevelUp = (skill, newLevel) => {
                log(`üìà SKILL UP! ${skill} niveau ${newLevel}`, 'success');
                updateSkillsDisplay();
                
                // D√©bloquage de nouvelles recettes
                if (newLevel >= 3) {
                    log(`üîì Nouvelles recettes d√©bloqu√©es pour ${skill}!`, 'success');
                }
            };
        }
        
        function updateMinigameUI() {
            const activeMinigameElement = document.getElementById('activeMinigame');
            if (!activeMinigameElement || !minigames) return;
            
            const activeMinigame = minigames.getActiveMinigame();
            
            if (activeMinigame) {
                const timeRemaining = Math.max(0, (activeMinigame.startTime + activeMinigame.duration - Date.now()) / 1000);
                activeMinigameElement.innerHTML = `
                    <div style="color: #FFD700;">${activeMinigame.name}</div>
                    <div style="color: #8A2BE2; font-size: 9px;">${Math.ceil(timeRemaining)}s restantes</div>
                `;
                
                // Auto-fermer quand termin√©
                if (timeRemaining <= 0) {
                    minigames.endCurrentMinigame();
                    updateMinigameUI();
                }
            } else {
                activeMinigameElement.innerHTML = 'Aucun mini-game actif';
            }
        }
        
        function updateSkillsDisplay() {
            if (!minigames) return;
            
            const skills = minigames.getGatheringSkills();
            
            const herbalismElement = document.getElementById('herbalismLevel');
            const chemistryElement = document.getElementById('chemistryLevel');
            const forgingElement = document.getElementById('forgingLevel');
            
            if (herbalismElement) herbalismElement.textContent = skills.herbalism || 1;
            if (chemistryElement) chemistryElement.textContent = skills.chemistry || 1;
            if (forgingElement) forgingElement.textContent = skills.foraging || 1;
        }

        // üí∞ ECONOMY BACKEND INTEGRATION
        function setupEconomyBackendCallbacks() {
            if (!economyBackend) return;
            
            // Callback inventaire mis √† jour
            economyBackend.onInventoryUpdated = (inventory) => {
                updateInventoryFromBackend(inventory);
                log('üí∞ Inventaire synchronis√© depuis backend', 'success');
            };
            
            // Callback ressource collect√©e
            economyBackend.onResourceCollected = (result) => {
                log(`üåø Ressource collect√©e: ${result.added?.length || 0} items`, 'success');
            };
            
            // Callback craft completed
            economyBackend.onCraftCompleted = (type, result) => {
                log(`üß™ ${type} cr√©√© avec succ√®s !`, 'success');
            };
            
            // Callback erreur
            economyBackend.onError = (operation, error, fallback) => {
                log(`‚ùå Backend ${operation}: ${error.message}`, 'warning');
            };
        }
        
        // üèÜ XP SYSTEM CALLBACKS
        function setupXPCallbacks() {
            if (!xpSystem) return;
            
            // Callbacks XP
            xpSystem.onXPGained = (source, amount, result) => {
                log(`üèÜ +${amount} XP (${source})`, 'success');
                
                // Mettre √† jour HUD si disponible
                updateXPDisplay(result);
                
                // Sauvegarder progression
                if (persistenceSystem) {
                    persistenceSystem.addHeroXP(amount, source);
                }
            };
            
            xpSystem.onLevelUp = (level, xp, xpNext) => {
                log(`üéâ LEVEL UP! Niveau ${level} atteint!`, 'success');
                showLevelUpNotification(level);
            };
            
            // Int√©grer XP aux √©v√©nements existants
            if (movement) {
                movement.onMoveEnd = (agentId, position, duration) => {
                    // Code existant...
                    xpSystem.onMovementCompleted(agentId, [], currentTimeVelocity);
                };
            }
            
            if (wsg) {
                wsg.onTCGTriggered = (matchId, entity1, entity2, result) => {
                    // üîß CORRECTION: XP auto backend pour TCG  
                    if (!XP_CONFIG.backendAutoXP.tcg) {
                        // Seulement si backend ne donne pas XP automatiquement
                        setTimeout(() => {
                            xpSystem.onTCGMatchEnd(matchId, result.winner, entity1, entity2);
                        }, 2000);
                    }
                };
            }
            
            if (fog) {
                fog.onTileExplored = (x, y, newEntities) => {
                    // üîß CORRECTION: XP auto backend pour collapse
                    if (!XP_CONFIG.backendAutoXP.collapse) {
                        // Seulement si backend ne donne pas XP automatiquement
                        xpSystem.onFogRevealed(1, newEntities || []);
                    }
                };
            }
            
            if (questSystem) {
                questSystem.onQuestCompleted = (questId, isMain) => {
                    xpSystem.onQuestCompleted(questId, isMain);
                };
                
                questSystem.onObjectiveCompleted = (questId, objectiveId) => {
                    xpSystem.onQuestObjectiveCompleted(questId, objectiveId);
                };
            }
        }
        
        // üíæ PERSISTENCE SYSTEM CALLBACKS  
        function setupPersistenceCallbacks() {
            if (!persistenceSystem) return;
            
            // Callbacks persistance
            persistenceSystem.onSaveCompleted = (data) => {
                log('üíæ Jeu sauvegard√© automatiquement', 'info');
            };
            
            persistenceSystem.onLoadCompleted = (data) => {
                log('üìÇ Sauvegarde charg√©e', 'success');
                
                // Restaurer √©tat UI depuis la sauvegarde
                if (data.hero) {
                    updateHeroDisplay(data.hero);
                }
                
                if (data.inventory) {
                    updateInventoryFromPersistence(data.inventory);
                }
                
                if (data.world) {
                    restoreWorldState(data.world);
                }
            };
            
            // Synchroniser avec autres syst√®mes
            if (inventory) {
                inventory.onResourceChanged = (type, amount) => {
                    persistenceSystem.addResource(type, amount);
                };
                
                inventory.onItemAdded = (itemId, item) => {
                    persistenceSystem.addItem(itemId, item);
                };
            }
            
            if (map) {
                map.onGatheringSpotCollected = (spot, playerId) => {
                    persistenceSystem.gatherSpot(spot.id);
                    
                    // üîß CORRECTION: XP auto backend pour collecte
                    if (!XP_CONFIG.backendAutoXP.collect) {
                        // Seulement si backend ne donne pas XP automatiquement
                        xpSystem.onResourceCollected(spot.id, [spot.type]);
                    }
                };
            }
        }
        
        // üöó TEMPORAL DRIFT CALLBACKS
        function setupTemporalDriftCallbacks() {
            if (!temporalDrift) return;
            
            // Callback apr√®s completion d'un drift
            temporalDrift.onDriftCompleted = (success, result) => {
                log(`üöó Drift ${success ? 'R√âUSSI' : '√âCHOU√â'}!`, success ? 'success' : 'warning');
                
                // üîß CORRECTION: Rafra√Æchir inventaire et XP apr√®s completion
                if (success && result) {
                    // Rafra√Æchir inventaire si rewards
                    if (result.inventory) {
                        refreshInventoryFromBackend();
                    }
                    
                    // Si XP dans les rewards, mettre √† jour l'affichage
                    if (result.xp) {
                        // üîß CORRECTION: XP auto backend pour arcade
                        if (!XP_CONFIG.backendAutoXP.arcade && xpSystem) {
                            // Seulement si backend ne donne pas XP automatiquement
                            xpSystem.addXP('drift_minigame', result.xp);
                        }
                        updateXPDisplay(result);
                    }
                }
                
                // Toujours rafra√Æchir inventaire pour √™tre s√ªr
                refreshInventoryFromBackend();
            };
            
            // Callback drift triggered
            temporalDrift.onDriftTriggered = (miniGameInfo) => {
                log(`üöó DRIFT D√âCLENCH√â: ${miniGameInfo.id}`, 'warning');
                
                // Optionnel: Jouer son/effet visuel
                if (driftHUD) {
                    driftHUD.showDriftWarning();
                }
            };
            
            // Callback zone changed
            temporalDrift.onZoneChanged = (oldZone, newZone) => {
                if (newZone === 'red') {
                    log('‚ö†Ô∏è ZONE ROUGE: Vitesse temporelle critique!', 'warning');
                } else if (newZone === 'amber') {
                    log('üü° ZONE AMBRE: Attention √† la vitesse', 'info');
                } else {
                    log('üü¢ ZONE VERTE: Vitesse normale', 'success');
                }
            };
        }
        
        // üéÆ HELPER FUNCTIONS
        function updateXPDisplay(heroData) {
            // Mettre √† jour affichage XP dans l'UI
            const xpElement = document.getElementById('heroXP');
            if (xpElement && heroData) {
                xpElement.textContent = `Niveau ${heroData.level} (${heroData.xp}/${heroData.xpNext})`;
            }
        }
        
        function showLevelUpNotification(level) {
            // Afficher notification level up
            const notification = document.createElement('div');
            notification.className = 'level-up-notification';
            notification.innerHTML = `üéâ NIVEAU ${level} ATTEINT!`;
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #FFD700, #FFA500); color: #000;
                padding: 20px 40px; border-radius: 15px; font-size: 1.5em; font-weight: bold;
                z-index: 10000; animation: levelUpPulse 3s ease; box-shadow: 0 0 30px #FFD700;
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }
        
        function updateInventoryFromPersistence(inventoryData) {
            // Synchroniser inventaire avec donn√©es persist√©es
            if (inventory && inventoryData.resources) {
                Object.entries(inventoryData.resources).forEach(([type, amount]) => {
                    inventory.resources[type] = amount;
                });
                updateInventoryUI();
            }
        }
        
        function restoreWorldState(worldData) {
            // Restaurer √©tat du monde depuis sauvegarde
            if (worldData.revealedTiles) {
                worldData.revealedTiles.forEach(tileKey => {
                    const [x, y] = tileKey.split(',').map(Number);
                    if (fog) fog.markObserved(x, y, 1);
                });
            }
            
            if (worldData.currentTopology) {
                currentTopology = worldData.currentTopology;
                updateTopology(currentTopology);
            }
        }
        
        async function refreshInventoryFromBackend() {
            if (!economyBackend) return;
            
            try {
                const inventory = await economyBackend.getInventory(true);
                updateInventoryFromBackend(inventory);
                log('‚úÖ Inventaire charg√© depuis backend', 'info');
            } catch (error) {
                log(`‚ùå Erreur chargement inventaire: ${error.message}`, 'error');
            }
        }
        
        function updateInventoryFromBackend(backendInventory) {
            if (!inventory || !backendInventory) return;
            
            // Synchroniser resources
            if (backendInventory.resources) {
                Object.entries(backendInventory.resources).forEach(([type, value]) => {
                    inventory.resources[type] = value;
                    updateResourceDisplay(type, value);
                });
            }
            
            // Synchroniser items
            if (backendInventory.items) {
                Object.entries(backendInventory.items).forEach(([id, item]) => {
                    inventory.items.set(id, item);
                });
            }
            
            // Synchroniser artifacts
            if (backendInventory.artifacts) {
                Object.entries(backendInventory.artifacts).forEach(([id, artifact]) => {
                    inventory.artifacts.set(id, artifact);
                });
            }
            
            updateInventoryUI();
        }
        
        // üßô‚Äç‚ôÇÔ∏è PANORAMIX POTIONS
        async function startPanoramixPotions() {
            if (!minigames) {
                log('‚ùå Syst√®me mini-games non initialis√©', 'error');
                return;
            }
            
            try {
                await minigames.startMinigame('panoramix_potions');
                
                // Interface simple de craft
                setTimeout(() => {
                    if (minigames.getActiveMinigame()?.id === 'panoramix_potions') {
                        showPanoramixInterface();
                    }
                }, 1000);
                
            } catch (error) {
                log(`‚ùå ${error.message}`, 'error');
            }
        }
        
        function showPanoramixInterface() {
            log('üßô‚Äç‚ôÇÔ∏è === ATELIER DE PANORAMIX ===', 'info');
            log('Recettes disponibles:', 'info');
            log('1. Potion de Vie (3 herbes, 1 eau, 1 miel)', 'info');
            log('2. √âlixir Temporel (2 essence temporelle, 5 herbes, 1 eau cristalline)', 'info');
            log('Tapez "craft potion_vie" pour cr√©er une potion !', 'info');
        }
        
        // üß™ SENKU CHEMISTRY
        async function startSenkuChemistry() {
            if (!minigames) {
                log('‚ùå Syst√®me mini-games non initialis√©', 'error');
                return;
            }
            
            try {
                await minigames.startMinigame('senku_chemistry');
                
                setTimeout(() => {
                    if (minigames.getActiveMinigame()?.id === 'senku_chemistry') {
                        showSenkuInterface();
                    }
                }, 1000);
                
            } catch (error) {
                log(`‚ùå ${error.message}`, 'error');
            }
        }
        
        function showSenkuInterface() {
            log('üß™ === LABORATOIRE DE SENKU ===', 'info');
            log('Formules disponibles:', 'info');
            log('1. Eau R√©gale (1 acide nitrique, 3 acide chlorhydrique)', 'info');
            log('2. Poudre Noire (1 soufre, 2 carbone, 3 nitrate potassium)', 'info');
            log('3. Savon Revival (2 graisse animale, 3 cendres, 1 alcool)', 'info');
            log('Tapez "chemistry aqua_regia" pour cr√©er !', 'info');
        }
        
        // üåø HERB COLLECTION
        async function startHerbCollection() {
            if (!minigames) {
                log('‚ùå Syst√®me mini-games non initialis√©', 'error');
                return;
            }
            
            try {
                await minigames.startMinigame('herb_collection');
                log('üåø Mode collecte activ√© ! Cliquez sur la carte pour r√©colter des herbes', 'success');
                
            } catch (error) {
                log(`‚ùå ${error.message}`, 'error');
            }
        }
        
        // ‚öíÔ∏è RUNIC FORGE
        async function startRunicForge() {
            if (!minigames) {
                log('‚ùå Syst√®me mini-games non initialis√©', 'error');
                return;
            }
            
            try {
                await minigames.startMinigame('runic_forge');
                log('‚öíÔ∏è Forge runique allum√©e ! Forgez des artefacts temporels', 'success');
                
            } catch (error) {
                log(`‚ùå ${error.message}`, 'error');
            }
        }
        
        // üó®Ô∏è COMMANDES CHAT POUR MINI-GAMES
        function handleMinigameCommand(command) {
            const parts = command.toLowerCase().split(' ');
            
            if (parts[0] === 'craft' && parts[1]) {
                handleCraftCommand(parts[1]);
            } else if (parts[0] === 'chemistry' && parts[1]) {
                handleChemistryCommand(parts[1]);
            } else if (parts[0] === 'collect') {
                // Auto-collecte √† position courante
                const selectedPos = document.getElementById('selectedPos').textContent;
                if (selectedPos !== 'Aucune') {
                    const coords = selectedPos.match(/\((\d+),(\d+)\)/);
                    if (coords) {
                        handleCollectCommand(parseInt(coords[1]), parseInt(coords[2]));
                    }
                }
            }
        }
        
        async function handleCraftCommand(recipeId) {
            if (!economyBackend) {
                log('‚ùå Backend √©conomie non disponible', 'error');
                return;
            }
            
            try {
                log(`üß™ Cr√©ation de la recette ${recipeId}...`, 'info');
                const result = await economyBackend.craftPotion(recipeId);
                log(`‚úÖ Craft r√©ussi: ${JSON.stringify(result.item)}`, 'success');
                
                // Rafra√Æchir l'inventaire UI
                await refreshInventoryFromBackend();
                
            } catch (error) {
                log(`‚ùå Erreur craft: ${error.message}`, 'error');
            }
        }
        
        async function handleChemistryCommand(formulaId) {
            if (!minigames || !minigames.getActiveMinigame()) {
                log('‚ùå Aucun laboratoire actif', 'error');
                return;
            }
            
            try {
                const result = await minigames.performChemistry(formulaId);
                log(`üß™ ${result.formula.name} cr√©√© avec succ√®s !`, 'success');
                log(`‚öóÔ∏è ${result.quote}`, 'info');
                
            } catch (error) {
                log(`‚ùå ${error.message}`, 'error');
            }
        }
        
        async function handleCollectCommand(x, y) {
            if (!economyBackend) {
                log('‚ùå Backend √©conomie non disponible', 'error');
                return;
            }
            
            try {
                // üîß CORRECTION: Utiliser spotId stables du backend au lieu de coordonn√©es
                const gatheringSpots = map ? map.getGatheringSpotsAt(x, y) : [];
                if (gatheringSpots.length === 0) {
                    log(`‚ùå Aucun point de collecte trouv√© en (${x}, ${y})`, 'warning');
                    return;
                }
                
                // Prendre le premier spot disponible
                const spot = gatheringSpots.find(s => s.available) || gatheringSpots[0];
                const spotId = spot.id;
                log(`üåø Collecte en cours au ${spotId} (${spot.type})...`, 'info');
                
                const result = await economyBackend.collectResource(spotId);
                log(`‚úÖ Collect√©: ${JSON.stringify(result.added)}`, 'success');
                
                // üîß CORRECTION: Marquer le spot comme collect√© dans map local
                if (map) {
                    map.markGatheringSpotCollected(spotId);
                }
                
                // Rafra√Æchir l'inventaire UI 
                await refreshInventoryFromBackend();
                
            } catch (error) {
                log(`‚ùå Erreur collecte: ${error.message}`, 'error');
            }
        }
        
        // üìù FONCTION COMMANDES
        function executeCommand() {
            const input = document.getElementById('commandInput');
            const command = input.value.trim();
            
            if (!command) return;
            
            log(`üí¨ Commande: ${command}`, 'info');
            
            // Traiter la commande
            handleMinigameCommand(command);
            
            // Vider le champ
            input.value = '';
        }
        
        // Mettre √† jour l'affichage mini-games toutes les 2 secondes
        setInterval(() => {
            if (minigames) {
                updateMinigameUI();
                updateSkillsDisplay();
            }
        }, 2000);
        
        // Functions pour les autres boutons (√† impl√©menter selon besoins)
        function forkAgent() { log('üîÄ forkAgent - √Ä impl√©menter', 'info'); }
    </script>
  <script src="./map-actions-dock.js"></script>
</body>
</html>
