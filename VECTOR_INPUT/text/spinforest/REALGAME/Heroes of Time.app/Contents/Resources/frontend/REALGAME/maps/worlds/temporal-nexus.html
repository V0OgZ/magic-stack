<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Nexus Temporel - Heroes of Time</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            overflow: hidden;
        }
        #temporalCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            background: rgba(138, 43, 226, 0.3);
            padding: 10px;
            border: 1px solid #8A2BE2;
        }
        .portal-indicator {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid #8A2BE2;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="temporalCanvas"></canvas>
    <div id="ui-overlay">
        <h3>üåÄ Nexus Temporel</h3>
        <p>Timeline: <span id="current-timeline">Flux Temporel</span></p>
        <p>Phase: <span id="phase-level">5</span>/6</p>
        <p>Mana: <span id="mana">100</span></p>
        <div>
            <button onclick="shiftTime(-1)">‚è™ Pass√©</button>
            <button onclick="shiftTime(1)">‚è© Futur</button>
        </div>
    </div>

    <script>
        // Configuration du Nexus Temporel
        const canvas = document.getElementById('temporalCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // √âtat de la carte temporelle
        const temporalMap = {
            width: 40,
            height: 40,
            tileSize: 32,
            currentTime: 0, // -3 = pass√© lointain, 0 = pr√©sent, +3 = futur lointain
            tiles: [],
            portals: [
                { x: 10, y: 10, to: 'avalon_central', active: true },
                { x: 30, y: 30, to: 'memory_realm', active: false, requiresTime: -2 },
                { x: 20, y: 5, to: 'crystal_dimension', active: false, requiresTime: 2 }
            ],
            temporalEntities: []
        };

        // Initialisation de la carte
        function initTemporalMap() {
            for (let y = 0; y < temporalMap.height; y++) {
                temporalMap.tiles[y] = [];
                for (let x = 0; x < temporalMap.width; x++) {
                    temporalMap.tiles[y][x] = {
                        type: Math.random() > 0.7 ? 'crystal' : 'void',
                        timeState: Math.floor(Math.random() * 7) - 3,
                        phased: Math.random() > 0.8
                    };
                }
            }

            // Cr√©atures temporelles
            for (let i = 0; i < 10; i++) {
                temporalMap.temporalEntities.push({
                    x: Math.random() * temporalMap.width,
                    y: Math.random() * temporalMap.height,
                    type: 'temporal_wisp',
                    existsAt: Math.floor(Math.random() * 7) - 3,
                    speed: 0.02 + Math.random() * 0.03
                });
            }
        }

        // Rendu de la carte
        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Effet de distorsion temporelle
            const time = Date.now() * 0.001;
            ctx.save();
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = '#8A2BE2';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(
                    canvas.width / 2 + Math.sin(time + i) * 200,
                    canvas.height / 2 + Math.cos(time + i) * 200,
                    100 + Math.sin(time * 2 + i) * 50,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            ctx.restore();

            // Rendu des tuiles
            const offsetX = (canvas.width - temporalMap.width * temporalMap.tileSize) / 2;
            const offsetY = (canvas.height - temporalMap.height * temporalMap.tileSize) / 2;

            for (let y = 0; y < temporalMap.height; y++) {
                for (let x = 0; x < temporalMap.width; x++) {
                    const tile = temporalMap.tiles[y][x];
                    const timeDiff = Math.abs(tile.timeState - temporalMap.currentTime);
                    
                    ctx.save();
                    ctx.globalAlpha = tile.phased ? 0.3 : Math.max(0.2, 1 - timeDiff * 0.2);
                    
                    if (tile.type === 'crystal') {
                        ctx.fillStyle = `hsl(${280 + tile.timeState * 20}, 70%, ${40 + timeDiff * 10}%)`;
                    } else {
                        ctx.fillStyle = `hsl(250, ${20 - timeDiff * 5}%, ${10 + timeDiff * 5}%)`;
                    }
                    
                    ctx.fillRect(
                        offsetX + x * temporalMap.tileSize,
                        offsetY + y * temporalMap.tileSize,
                        temporalMap.tileSize - 1,
                        temporalMap.tileSize - 1
                    );
                    ctx.restore();
                }
            }

            // Rendu des entit√©s temporelles
            temporalMap.temporalEntities.forEach(entity => {
                if (Math.abs(entity.existsAt - temporalMap.currentTime) < 2) {
                    ctx.save();
                    ctx.globalAlpha = 1 - Math.abs(entity.existsAt - temporalMap.currentTime) * 0.3;
                    ctx.fillStyle = '#E0B0FF';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#8A2BE2';
                    
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + entity.x * temporalMap.tileSize,
                        offsetY + entity.y * temporalMap.tileSize,
                        5 + Math.sin(time * 3) * 2,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    ctx.restore();
                }
                
                // Mouvement temporel
                entity.x += Math.sin(time + entity.existsAt) * entity.speed;
                entity.y += Math.cos(time + entity.existsAt) * entity.speed;
                
                // Wrap around
                if (entity.x < 0) entity.x = temporalMap.width;
                if (entity.x > temporalMap.width) entity.x = 0;
                if (entity.y < 0) entity.y = temporalMap.height;
                if (entity.y > temporalMap.height) entity.y = 0;
            });

            // Rendu des portails
            temporalMap.portals.forEach(portal => {
                const canActivate = !portal.requiresTime || portal.requiresTime === temporalMap.currentTime;
                
                ctx.save();
                ctx.globalAlpha = canActivate ? 1 : 0.3;
                ctx.strokeStyle = canActivate ? '#8A2BE2' : '#444';
                ctx.lineWidth = 3;
                ctx.shadowBlur = canActivate ? 30 : 0;
                ctx.shadowColor = '#8A2BE2';
                
                ctx.beginPath();
                ctx.arc(
                    offsetX + portal.x * temporalMap.tileSize,
                    offsetY + portal.y * temporalMap.tileSize,
                    20 + Math.sin(time * 2) * 5,
                    0, Math.PI * 2
                );
                ctx.stroke();
                
                if (canActivate) {
                    // Effet de rotation pour les portails actifs
                    ctx.save();
                    ctx.translate(
                        offsetX + portal.x * temporalMap.tileSize,
                        offsetY + portal.y * temporalMap.tileSize
                    );
                    ctx.rotate(time);
                    ctx.strokeStyle = '#E0B0FF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-15, -15, 30, 30);
                    ctx.restore();
                }
                
                ctx.restore();
            });

            requestAnimationFrame(render);
        }

        // D√©calage temporel
        function shiftTime(direction) {
            temporalMap.currentTime = Math.max(-3, Math.min(3, temporalMap.currentTime + direction));
            document.getElementById('phase-level').textContent = 3 + temporalMap.currentTime;
            
            // Mise √† jour des portails
            temporalMap.portals.forEach(portal => {
                if (portal.requiresTime && portal.requiresTime === temporalMap.currentTime) {
                    portal.active = true;
                    console.log(`Portal vers ${portal.to} activ√©!`);
                }
            });
        }

        // Gestion des clics pour activer les portails
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const offsetX = (canvas.width - temporalMap.width * temporalMap.tileSize) / 2;
            const offsetY = (canvas.height - temporalMap.height * temporalMap.tileSize) / 2;
            
            temporalMap.portals.forEach(portal => {
                const px = offsetX + portal.x * temporalMap.tileSize;
                const py = offsetY + portal.y * temporalMap.tileSize;
                const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
                
                if (dist < 30 && portal.active) {
                    console.log(`T√©l√©portation vers ${portal.to}!`);
                    // Ici on pourrait rediriger vers la carte correspondante
                    window.location.href = portal.to === 'avalon_central' ? '../main/MainIsoMap.html' : `${portal.to}.html`;
                }
            });
        });

        // Initialisation
        initTemporalMap();
        render();
    </script>
</body>
</html>