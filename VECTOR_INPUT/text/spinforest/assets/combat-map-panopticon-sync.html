<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è Combat MAP + Panopticon 6D Sync</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            overflow: hidden;
        }
        
        #container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 200px;
            height: 100vh;
            gap: 2px;
        }
        
        /* MAP DE JEU */
        #map-container {
            background: #001100;
            border: 2px solid #00ff00;
            position: relative;
            overflow: hidden;
        }
        
        #game-map {
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 100, 0, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(100, 50, 0, 0.3) 0%, transparent 50%),
                linear-gradient(45deg, #001100 25%, transparent 25%),
                linear-gradient(-45deg, #001100 25%, transparent 25%);
            background-size: 50px 50px, 50px 50px, 20px 20px, 20px 20px;
            position: relative;
        }
        
        .hero {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
        }
        
        .hero:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px currentColor;
        }
        
        .hero.vincent { background: #ff00ff; border-color: #ff00ff; color: white; }
        .hero.loumen { background: #00ffff; border-color: #00ffff; color: black; }
        .hero.sid { background: #ff6600; border-color: #ff6600; color: white; }
        .hero.urz { background: #00ff00; border-color: #00ff00; color: black; }
        .hero.grokaen { background: #0066ff; border-color: #0066ff; color: white; }
        
        .spell-effect {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
        
        .fireball {
            background: radial-gradient(circle, #ff6600 0%, #ff0000 50%, transparent 100%);
            animation: spell-cast 2s ease-out forwards;
        }
        
        .lightning-bolt {
            background: radial-gradient(circle, #ffff00 0%, #ffffff 50%, transparent 100%);
            animation: lightning-cast 1s ease-out forwards;
        }
        
        .heal {
            background: radial-gradient(circle, #00ff00 0%, #ffffff 50%, transparent 100%);
            animation: heal-cast 1.5s ease-out forwards;
        }
        
        @keyframes spell-cast {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        @keyframes lightning-cast {
            0% { transform: scale(0) rotate(0deg); opacity: 1; }
            50% { transform: scale(2) rotate(180deg); opacity: 1; }
            100% { transform: scale(4) rotate(360deg); opacity: 0; }
        }
        
        @keyframes heal-cast {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        
        /* PANOPTICON 6D */
        #panopticon-container {
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
            border: 2px solid #00ffff;
            position: relative;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .lightning-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .lightning-active {
            opacity: 1;
            animation: combat-lightning 1s ease-out;
        }
        
        @keyframes combat-lightning {
            0% { background: radial-gradient(circle at center, rgba(255, 0, 0, 0.8) 0%, transparent 70%); }
            25% { background: radial-gradient(circle at center, rgba(255, 255, 0, 0.6) 0%, transparent 60%); }
            50% { background: radial-gradient(circle at center, rgba(0, 255, 255, 0.7) 0%, transparent 50%); }
            75% { background: radial-gradient(circle at center, rgba(255, 0, 255, 0.5) 0%, transparent 80%); }
            100% { background: transparent; }
        }
        
        /* CONTR√îLES */
        #controls-container {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.9);
            border-top: 2px solid #00ff00;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            overflow-x: auto;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 120px;
        }
        
        .control-btn {
            padding: 8px 12px;
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .spell-btn.fireball { border-color: #ff6600; color: #ff6600; }
        .spell-btn.lightning { border-color: #ffff00; color: #ffff00; }
        .spell-btn.heal { border-color: #00ff00; color: #00ff00; }
        
        .status-display {
            display: flex;
            gap: 20px;
            margin-left: auto;
            font-size: 0.9em;
        }
        
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .sync-indicator {
            color: #ffff00;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- MAP DE JEU -->
        <div id="map-container">
            <div id="game-map">
                <div class="hero vincent" id="hero-vincent" style="left: 50%; top: 50%;">V</div>
                <div class="hero loumen" id="hero-loumen" style="left: 20%; top: 30%;">L</div>
                <div class="hero sid" id="hero-sid" style="left: 80%; top: 20%;">S</div>
                <div class="hero urz" id="hero-urz" style="left: 70%; top: 70%;">U</div>
                <div class="hero grokaen" id="hero-grokaen" style="left: 30%; top: 80%;">G</div>
            </div>
        </div>
        
        <!-- PANOPTICON 6D -->
        <div id="panopticon-container">
            <canvas id="canvas3d"></canvas>
            <div class="lightning-overlay" id="lightning-overlay"></div>
        </div>
        
        <!-- CONTR√îLES -->
        <div id="controls-container">
            <div class="control-group">
                <label>üèπ H√©ros Actif</label>
                <select id="active-hero" class="control-btn">
                    <option value="vincent">Vincent (V)</option>
                    <option value="loumen">Loumen (L)</option>
                    <option value="sid">Sid (S)</option>
                    <option value="urz">Urz-K√¥m (U)</option>
                    <option value="grokaen">Grok√¶n (G)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>‚öîÔ∏è Sorts</label>
                <div style="display: flex; gap: 5px;">
                    <button class="control-btn spell-btn fireball" onclick="castSpell('fireball')">üî• Fireball</button>
                    <button class="control-btn spell-btn lightning" onclick="castSpell('lightning')">‚ö° Lightning</button>
                    <button class="control-btn spell-btn heal" onclick="castSpell('heal')">üíö Heal</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>üéÆ Actions</label>
                <div style="display: flex; gap: 5px;">
                    <button class="control-btn" onclick="moveHero()">üö∂ Move</button>
                    <button class="control-btn" onclick="attackTarget()">‚öîÔ∏è Attack</button>
                    <button class="control-btn" onclick="defendHero()">üõ°Ô∏è Defend</button>
                </div>
            </div>
            
            <div class="status-display">
                <div class="status-item">
                    <span>üîó Backend</span>
                    <span id="backend-status">Connect√©</span>
                </div>
                <div class="status-item">
                    <span>‚ö° Sync</span>
                    <span id="sync-status" class="sync-indicator">ACTIVE</span>
                </div>
                <div class="status-item">
                    <span>üß† Neural</span>
                    <span id="neural-activity">0%</span>
                </div>
                <div class="status-item">
                    <span>‚öîÔ∏è Combats</span>
                    <span id="combat-count">0</span>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration
        const CONFIG = {
            backendUrl: 'http://localhost:8082',
            syncInterval: 1000,
            combatAnimationDuration: 2000
        };
        
        // Variables globales
        let scene, camera, renderer;
        let activeDimension = 'CAUSALE';
        let worldStateGraph = null;
        let combatCount = 0;
        let activeHero = 'vincent';
        
        // Positions des h√©ros en 6D
        const heroPositions6D = {
            vincent: { x: 50, y: 50, z: 50, activity: 0.8 },
            loumen: { x: 4.82, y: 58.01, z: 29.73, activity: 0.6 },
            sid: { x: 100, y: 5, z: 45, activity: 0.4 },
            urz: { x: 109, y: 13, z: 60, activity: 0.7 },
            grokaen: { x: 105, y: 15, z: 40, activity: 0.5 }
        };
        
        // Initialisation
        async function init() {
            console.log('‚öîÔ∏è Initialisation Combat MAP + Panopticon Sync');
            
            initThreeJS();
            await connectToBackend();
            setupMapEvents();
            startSyncLoop();
            loadNeuralNetwork();
            
            animate();
        }
        
        // Connexion backend
        async function connectToBackend() {
            try {
                const response = await fetch(`${CONFIG.backendUrl}/api/interstice/status`);
                if (response.ok) {
                    document.getElementById('backend-status').textContent = 'UP';
                    document.getElementById('backend-status').style.color = '#00ff00';
                } else {
                    throw new Error('Backend down');
                }
            } catch (error) {
                document.getElementById('backend-status').textContent = 'DOWN';
                document.getElementById('backend-status').style.color = '#ff0000';
            }
        }
        
        // Configuration Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas3d'), antialias: true });
            
            const container = document.getElementById('panopticon-container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            // Lumi√®res
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            camera.position.set(0, 0, 15);
        }
        
        // Chargement r√©seau neuronal
        function loadNeuralNetwork() {
            worldStateGraph = {
                nodes: Object.entries(heroPositions6D).map(([id, pos]) => ({
                    id: id.toUpperCase(),
                    name: id.charAt(0).toUpperCase() + id.slice(1),
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    activity: pos.activity,
                    type: 'HERO'
                })),
                edges: [
                    { from: 'VINCENT', to: 'LOUMEN', strength: 0.9, type: 'COMMAND' },
                    { from: 'VINCENT', to: 'SID', strength: 0.8, type: 'DIRECTIVE' },
                    { from: 'LOUMEN', to: 'URZ', strength: 0.7, type: 'COLLABORATION' },
                    { from: 'SID', to: 'GROKAEN', strength: 0.6, type: 'COORDINATION' }
                ]
            };
            
            renderNeuralNetwork();
            updateNeuralActivity();
        }
        
        // Rendu r√©seau neuronal
        function renderNeuralNetwork() {
            // Nettoyer la sc√®ne
            while(scene.children.length > 2) {
                scene.remove(scene.children[2]);
            }
            
            if (!worldStateGraph) return;
            
            // Couleurs par h√©ros
            const heroColors = {
                VINCENT: 0xff00ff,
                LOUMEN: 0x00ffff,
                SID: 0xff6600,
                URZ: 0x00ff00,
                GROKAEN: 0x0066ff
            };
            
            // Rendu des neurones h√©ros
            worldStateGraph.nodes.forEach(node => {
                const activity = node.activity || 0;
                const size = 0.4 + (activity * 0.4);
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                
                const color = heroColors[node.id] || 0x333333;
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: activity * 0.4
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(
                    node.x / 20 - 2.5, 
                    node.y / 20 - 2.5, 
                    node.z / 20 - 2.5
                );
                sphere.userData = node;
                
                // Animation de pulse
                const time = Date.now() * 0.003;
                sphere.scale.setScalar(1 + Math.sin(time + node.x) * 0.1);
                
                scene.add(sphere);
                
                // √âtiquette
                const textGeometry = new THREE.RingGeometry(size + 0.1, size + 0.2, 8);
                const textMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: activity
                });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(
                    node.x / 20 - 2.5, 
                    node.y / 20 - 2.5 + 0.8, 
                    node.z / 20 - 2.5
                );
                scene.add(textMesh);
            });
            
            // Rendu des connexions
            worldStateGraph.edges.forEach(edge => {
                const fromNode = worldStateGraph.nodes.find(n => n.id === edge.from);
                const toNode = worldStateGraph.nodes.find(n => n.id === edge.to);
                
                if (fromNode && toNode) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(fromNode.x / 20 - 2.5, fromNode.y / 20 - 2.5, fromNode.z / 20 - 2.5),
                        new THREE.Vector3(toNode.x / 20 - 2.5, toNode.y / 20 - 2.5, toNode.z / 20 - 2.5)
                    ]);
                    
                    const intensity = (fromNode.activity + toNode.activity) / 2;
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0x00ffff,
                        opacity: edge.strength * intensity,
                        transparent: true
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                }
            });
        }
        
        // Lancement de sort
        function castSpell(spellType) {
            const heroId = document.getElementById('active-hero').value;
            const heroElement = document.getElementById(`hero-${heroId}`);
            
            if (!heroElement) return;
            
            // Effet sur la MAP
            const rect = heroElement.getBoundingClientRect();
            const mapRect = document.getElementById('game-map').getBoundingClientRect();
            
            const spellEffect = document.createElement('div');
            spellEffect.className = `spell-effect ${spellType}`;
            spellEffect.style.left = (rect.left - mapRect.left - 10) + 'px';
            spellEffect.style.top = (rect.top - mapRect.top - 10) + 'px';
            
            document.getElementById('game-map').appendChild(spellEffect);
            
            // Supprimer l'effet apr√®s animation
            setTimeout(() => {
                if (spellEffect.parentNode) {
                    spellEffect.parentNode.removeChild(spellEffect);
                }
            }, CONFIG.combatAnimationDuration);
            
            // Effet sur le Panopticon
            triggerCombatLightning(spellType);
            
            // Boost d'activit√© neuronale
            const heroData = heroPositions6D[heroId];
            if (heroData) {
                heroData.activity = Math.min(1, heroData.activity + 0.3);
                
                // Mettre √† jour le neurone correspondant
                const node = worldStateGraph.nodes.find(n => n.id === heroId.toUpperCase());
                if (node) {
                    node.activity = heroData.activity;
                }
            }
            
            // Synchroniser avec backend
            syncCombatWithBackend(heroId, spellType);
            
            combatCount++;
            document.getElementById('combat-count').textContent = combatCount;
            
            console.log(`‚öîÔ∏è ${heroId} lance ${spellType}!`);
        }
        
        // Lightning de combat
        function triggerCombatLightning(spellType) {
            const overlay = document.getElementById('lightning-overlay');
            overlay.classList.add('lightning-active');
            
            setTimeout(() => {
                overlay.classList.remove('lightning-active');
            }, 1000);
        }
        
        // Synchronisation avec backend
        async function syncCombatWithBackend(heroId, action) {
            try {
                const response = await fetch(`${CONFIG.backendUrl}/api/panopticon/feature-log`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        mageId: heroId.toUpperCase(),
                        feature: `Combat: ${action}`,
                        description: `${heroId} utilise ${action} en combat`,
                        color: getSpellColor(action),
                        coordinates: heroPositions6D[heroId]
                    })
                });
                
                if (response.ok) {
                    console.log('‚úÖ Combat synchronis√© avec backend');
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Erreur sync backend:', error);
            }
        }
        
        // Couleur par sort
        function getSpellColor(spellType) {
            switch(spellType) {
                case 'fireball': return '#ff6600';
                case 'lightning': return '#ffff00';
                case 'heal': return '#00ff00';
                default: return '#ffffff';
            }
        }
        
        // Actions h√©ros
        function moveHero() {
            const heroId = document.getElementById('active-hero').value;
            const heroElement = document.getElementById(`hero-${heroId}`);
            
            // Mouvement al√©atoire
            const newLeft = Math.random() * 80 + 10; // 10% √† 90%
            const newTop = Math.random() * 80 + 10;
            
            heroElement.style.left = newLeft + '%';
            heroElement.style.top = newTop + '%';
            
            // Mettre √† jour position 6D
            const heroData = heroPositions6D[heroId];
            heroData.x = newLeft;
            heroData.y = newTop;
            heroData.activity = Math.min(1, heroData.activity + 0.1);
            
            syncCombatWithBackend(heroId, 'move');
            console.log(`üö∂ ${heroId} se d√©place`);
        }
        
        function attackTarget() {
            castSpell('fireball'); // Attaque = fireball par d√©faut
        }
        
        function defendHero() {
            castSpell('heal'); // D√©fense = heal par d√©faut
        }
        
        // Configuration √©v√©nements MAP
        function setupMapEvents() {
            // Clic sur h√©ros pour le s√©lectionner
            document.querySelectorAll('.hero').forEach(hero => {
                hero.addEventListener('click', () => {
                    const heroId = hero.id.replace('hero-', '');
                    document.getElementById('active-hero').value = heroId;
                    
                    // Highlight
                    document.querySelectorAll('.hero').forEach(h => h.style.transform = 'scale(1)');
                    hero.style.transform = 'scale(1.3)';
                });
            });
            
            // Clic sur map pour d√©placer h√©ros actif
            document.getElementById('game-map').addEventListener('click', (e) => {
                const heroId = document.getElementById('active-hero').value;
                const heroElement = document.getElementById(`hero-${heroId}`);
                const rect = e.currentTarget.getBoundingClientRect();
                
                const x = ((e.clientX - rect.left) / rect.width) * 100;
                const y = ((e.clientY - rect.top) / rect.height) * 100;
                
                heroElement.style.left = x + '%';
                heroElement.style.top = y + '%';
                
                // Sync 6D
                heroPositions6D[heroId].x = x;
                heroPositions6D[heroId].y = y;
                
                syncCombatWithBackend(heroId, 'move');
            });
        }
        
        // Mise √† jour activit√© neuronale
        function updateNeuralActivity() {
            const totalActivity = Object.values(heroPositions6D).reduce((sum, hero) => sum + hero.activity, 0);
            const avgActivity = (totalActivity / Object.keys(heroPositions6D).length * 100).toFixed(1);
            document.getElementById('neural-activity').textContent = avgActivity + '%';
        }
        
        // Boucle de synchronisation
        function startSyncLoop() {
            setInterval(() => {
                // D√©croissance naturelle de l'activit√©
                Object.values(heroPositions6D).forEach(hero => {
                    hero.activity = Math.max(0.2, hero.activity - 0.02);
                });
                
                // Mettre √† jour les neurones
                worldStateGraph.nodes.forEach(node => {
                    const heroData = heroPositions6D[node.id.toLowerCase()];
                    if (heroData) {
                        node.activity = heroData.activity;
                        node.x = heroData.x;
                        node.y = heroData.y;
                    }
                });
                
                renderNeuralNetwork();
                updateNeuralActivity();
                
            }, CONFIG.syncInterval);
        }
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotation lente de la cam√©ra
            const time = Date.now() * 0.0002;
            camera.position.x = Math.cos(time) * 12;
            camera.position.z = Math.sin(time) * 12;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Gestion redimensionnement
        window.addEventListener('resize', () => {
            const container = document.getElementById('panopticon-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // Initialisation
        window.addEventListener('load', init);
    </script>
</body>
</html>