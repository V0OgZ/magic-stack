<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî¨ Tests Scientifiques Moteur 6D - Heroes of Time</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
        }
        
        .test-controls {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            font-family: inherit;
            transition: all 0.3s;
        }
        
        button:hover {
            background: rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 10px #00ff00;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .test-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .category {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            padding: 15px;
            border-radius: 10px;
        }
        
        .category h3 {
            color: #ffff00;
            margin-top: 0;
        }
        
        .test-results {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            padding: 20px;
            border-radius: 10px;
            height: 500px;
            overflow-y: auto;
        }
        
        .test-result {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .test-pass {
            background: rgba(0, 255, 0, 0.1);
            border-left: 4px solid #00ff00;
        }
        
        .test-fail {
            background: rgba(255, 0, 0, 0.1);
            border-left: 4px solid #ff0000;
        }
        
        .test-info {
            background: rgba(0, 255, 255, 0.1);
            border-left: 4px solid #00ffff;
        }
        
        .stats {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .stat-item {
            text-align: center;
            margin: 10px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ffff00;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff);
            transition: width 0.3s;
            width: 0%;
        }
        
        pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
        }
        
        .assertion {
            color: #ff00ff;
            font-weight: bold;
        }
        
        .expected {
            color: #00ff00;
        }
        
        .actual {
            color: #ff0000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Tests Scientifiques Moteur 6D üî¨</h1>
        
        <div class="test-controls">
            <button id="runHighwayTests">üõ£Ô∏è Tests Autoroute (50)</button>
            <button id="runEdgeCaseTests">üåÄ Tests Cas Limites (100)</button>
            <button id="runAllTests">üöÄ Tous les Tests</button>
            <button id="stopTests">‚èπÔ∏è Arr√™ter</button>
            <button id="clearResults">üóëÔ∏è Effacer</button>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
        </div>
        
        <div class="test-categories">
            <div class="category">
                <h3>‚è∞ Tests Temporels</h3>
                <ul>
                    <li>Superposition d'√©tats</li>
                    <li>Collapse causal</li>
                    <li>Brouillard temporel</li>
                    <li>Voyages dans le temps</li>
                    <li>Paradoxes temporels</li>
                </ul>
            </div>
            
            <div class="category">
                <h3>üåÄ Tests Quantiques</h3>
                <ul>
                    <li>Intrication ER=EPR</li>
                    <li>T√©l√©portation quantique</li>
                    <li>Interf√©rences probabilistes</li>
                    <li>Mesure et observation</li>
                    <li>D√©coh√©rence</li>
                </ul>
            </div>
            
            <div class="category">
                <h3>üî∑ Tests Causaux</h3>
                <ul>
                    <li>C√¥nes de causalit√©</li>
                    <li>Propagation causale</li>
                    <li>Blocage potentiel</li>
                    <li>R√©solution de conflits</li>
                    <li>Graphe causal</li>
                </ul>
            </div>
            
            <div class="category">
                <h3>üéÆ Tests Gameplay</h3>
                <ul>
                    <li>Actions simultan√©es</li>
                    <li>Multi-timeline</li>
                    <li>Synchronisation joueurs</li>
                    <li>R√©solution de combat</li>
                    <li>Effets d'artefacts</li>
                </ul>
            </div>
        </div>
        
        <div class="test-results" id="testResults">
            <div class="test-info">üî¨ Pr√™t √† lancer les tests scientifiques du moteur 6D...</div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="totalTests">0</div>
                <div>Tests Total</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="passedTests" style="color: #00ff00;">0</div>
                <div>R√©ussis</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="failedTests" style="color: #ff0000;">0</div>
                <div>√âchou√©s</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="successRate">0%</div>
                <div>Taux de R√©ussite</div>
            </div>
        </div>
    </div>

    <script>
        // √âtat global des tests
        const testState = {
            running: false,
            results: [],
            passed: 0,
            failed: 0,
            total: 0,
            backendUrl: 'http://localhost:8080'
        };

        // Utilitaires d'assertion
        class Assert {
            static equals(actual, expected, message) {
                if (actual === expected) {
                    return { pass: true, message: `‚úì ${message}` };
                } else {
                    return { 
                        pass: false, 
                        message: `‚úó ${message}`,
                        details: `Expected: ${JSON.stringify(expected)}, Actual: ${JSON.stringify(actual)}`
                    };
                }
            }

            static notEquals(actual, expected, message) {
                if (actual !== expected) {
                    return { pass: true, message: `‚úì ${message}` };
                } else {
                    return { 
                        pass: false, 
                        message: `‚úó ${message}`,
                        details: `Should not equal: ${JSON.stringify(expected)}`
                    };
                }
            }

            static isTrue(condition, message) {
                if (condition) {
                    return { pass: true, message: `‚úì ${message}` };
                } else {
                    return { pass: false, message: `‚úó ${message}` };
                }
            }

            static isFalse(condition, message) {
                return this.isTrue(!condition, message);
            }

            static contains(array, item, message) {
                if (array.includes(item)) {
                    return { pass: true, message: `‚úì ${message}` };
                } else {
                    return { 
                        pass: false, 
                        message: `‚úó ${message}`,
                        details: `Array does not contain: ${JSON.stringify(item)}`
                    };
                }
            }

            static async throwsError(asyncFn, message) {
                try {
                    await asyncFn();
                    return { pass: false, message: `‚úó ${message} - No error thrown` };
                } catch (e) {
                    return { pass: true, message: `‚úì ${message}` };
                }
            }
        }

        // Tests Autoroute (gameplay standard)
        const highwayTests = [
            {
                name: "Test 1: Cr√©ation de partie basique",
                category: "gameplay",
                async run() {
                    const result = await mockBackendCall('/api/games/create', {
                        method: 'POST',
                        body: { name: 'Test Game', world: 'mystique' }
                    });
                    return Assert.isTrue(result.id !== undefined, "La partie doit avoir un ID");
                }
            },
            {
                name: "Test 2: D√©placement de h√©ros simple",
                category: "gameplay",
                async run() {
                    const moveData = { heroId: 'arthur', x: 5, y: 5 };
                    const result = await mockBackendCall('/api/heroes/move', {
                        method: 'POST',
                        body: moveData
                    });
                    return Assert.equals(result.position.x, 5, "Le h√©ros doit √™tre √† x=5");
                }
            },
            {
                name: "Test 3: Combat basique",
                category: "gameplay",
                async run() {
                    const combatData = { attacker: 'arthur', target: 'goblin' };
                    const result = await mockBackendCall('/api/combat/attack', {
                        method: 'POST',
                        body: combatData
                    });
                    return Assert.isTrue(result.damage > 0, "Le combat doit infliger des d√©g√¢ts");
                }
            },
            {
                name: "Test 4: Collecte de ressource",
                category: "gameplay",
                async run() {
                    const result = await mockBackendCall('/api/resources/collect', {
                        method: 'POST',
                        body: { heroId: 'arthur', resourceId: 'gold_1' }
                    });
                    return Assert.isTrue(result.collected, "La ressource doit √™tre collect√©e");
                }
            },
            {
                name: "Test 5: Utilisation d'artefact",
                category: "gameplay",
                async run() {
                    const result = await mockBackendCall('/api/artifacts/use', {
                        method: 'POST',
                        body: { heroId: 'arthur', artifactId: 'excalibur' }
                    });
                    return Assert.isTrue(result.effectApplied, "L'effet de l'artefact doit √™tre appliqu√©");
                }
            },
            // ... Ajouter plus de tests autoroute jusqu'√† 50
        ];

        // Tests Cas Limites (edge cases)
        const edgeCaseTests = [
            {
                name: "Edge 1: Superposition maximale (10 √©tats)",
                category: "quantum",
                async run() {
                    const states = [];
                    for (let i = 0; i < 10; i++) {
                        states.push({ probability: 0.1, state: `state_${i}` });
                    }
                    const result = await mockBackendCall('/api/quantum/superposition', {
                        method: 'POST',
                        body: { states }
                    });
                    return Assert.equals(result.states.length, 10, "Doit supporter 10 √©tats superpos√©s");
                }
            },
            {
                name: "Edge 2: Paradoxe temporel - tuer son grand-p√®re",
                category: "temporal",
                async run() {
                    const result = await mockBackendCall('/api/temporal/paradox', {
                        method: 'POST',
                        body: { 
                            action: 'kill',
                            target: 'grandfather',
                            timeline: 'past'
                        }
                    });
                    return Assert.isTrue(result.paradoxResolved, "Le paradoxe doit √™tre r√©solu");
                }
            },
            {
                name: "Edge 3: Brouillard causal √† distance infinie",
                category: "causal",
                async run() {
                    const result = await mockBackendCall('/api/causal/fog', {
                        method: 'GET',
                        params: { distance: 999999 }
                    });
                    return Assert.equals(result.visibility, 0, "Visibilit√© nulle √† distance infinie");
                }
            },
            {
                name: "Edge 4: Intrication ER=EPR avec 100 wormholes",
                category: "quantum",
                async run() {
                    const wormholes = [];
                    for (let i = 0; i < 100; i++) {
                        wormholes.push({ id: `wh_${i}`, pair: `wh_${(i+1)%100}` });
                    }
                    const result = await mockBackendCall('/api/er-epr/create-network', {
                        method: 'POST',
                        body: { wormholes }
                    });
                    return Assert.isTrue(result.networkStable, "Le r√©seau de 100 wormholes doit √™tre stable");
                }
            },
            {
                name: "Edge 5: Collapse simultan√© de 50 superpositions",
                category: "quantum",
                async run() {
                    const collapses = [];
                    for (let i = 0; i < 50; i++) {
                        collapses.push({ superpositionId: `sup_${i}`, forceState: 0 });
                    }
                    const result = await mockBackendCall('/api/quantum/collapse-batch', {
                        method: 'POST',
                        body: { collapses }
                    });
                    return Assert.equals(result.collapsed.length, 50, "Les 50 superpositions doivent √™tre collaps√©es");
                }
            },
            // ... Ajouter plus de tests edge case
        ];

        // Simulateur de backend (pour les tests sans backend r√©el)
        async function mockBackendCall(endpoint, options = {}) {
            // Simuler un d√©lai r√©seau
            await new Promise(resolve => setTimeout(resolve, Math.random() * 50));
            
            // Simuler des r√©ponses selon l'endpoint
            if (endpoint.includes('/games/create')) {
                return { id: 'game_' + Date.now(), status: 'created' };
            }
            if (endpoint.includes('/heroes/move')) {
                return { position: options.body, moved: true };
            }
            if (endpoint.includes('/combat/attack')) {
                return { damage: Math.floor(Math.random() * 50) + 10, hit: true };
            }
            if (endpoint.includes('/resources/collect')) {
                return { collected: true, amount: Math.floor(Math.random() * 100) };
            }
            if (endpoint.includes('/artifacts/use')) {
                return { effectApplied: true, duration: 5 };
            }
            if (endpoint.includes('/quantum/superposition')) {
                return { states: options.body.states, created: true };
            }
            if (endpoint.includes('/temporal/paradox')) {
                return { paradoxResolved: true, method: 'timeline_split' };
            }
            if (endpoint.includes('/causal/fog')) {
                const distance = parseInt(options.params?.distance || 0);
                return { visibility: Math.max(0, 1 - distance / 1000) };
            }
            if (endpoint.includes('/er-epr/create-network')) {
                return { networkStable: options.body.wormholes.length <= 100 };
            }
            if (endpoint.includes('/quantum/collapse-batch')) {
                return { collapsed: options.body.collapses };
            }
            
            // Par d√©faut
            return { success: true, data: {} };
        }

        // Fonction pour ex√©cuter un test
        async function runTest(test) {
            const startTime = Date.now();
            try {
                const result = await test.run();
                const duration = Date.now() - startTime;
                
                if (result.pass) {
                    testState.passed++;
                    logResult('pass', `[${test.category}] ${test.name}`, result.message, duration);
                } else {
                    testState.failed++;
                    logResult('fail', `[${test.category}] ${test.name}`, result.message, duration, result.details);
                }
            } catch (error) {
                testState.failed++;
                const duration = Date.now() - startTime;
                logResult('fail', `[${test.category}] ${test.name}`, `Error: ${error.message}`, duration);
            }
            
            testState.total++;
            updateStats();
            updateProgress();
        }

        // Logger les r√©sultats
        function logResult(type, testName, message, duration, details = '') {
            const resultsDiv = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result test-${type}`;
            
            let html = `<strong>${testName}</strong> (${duration}ms)<br>${message}`;
            if (details) {
                html += `<br><small>${details}</small>`;
            }
            
            resultDiv.innerHTML = html;
            resultsDiv.appendChild(resultDiv);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        // Mettre √† jour les statistiques
        function updateStats() {
            document.getElementById('totalTests').textContent = testState.total;
            document.getElementById('passedTests').textContent = testState.passed;
            document.getElementById('failedTests').textContent = testState.failed;
            
            const successRate = testState.total > 0 
                ? Math.round((testState.passed / testState.total) * 100) 
                : 0;
            document.getElementById('successRate').textContent = successRate + '%';
        }

        // Mettre √† jour la barre de progression
        function updateProgress() {
            const totalTests = highwayTests.length + edgeCaseTests.length;
            const progress = (testState.total / totalTests) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        // Ex√©cuter une suite de tests
        async function runTestSuite(tests, suiteName) {
            logResult('info', suiteName, `D√©marrage de ${tests.length} tests...`, 0);
            
            for (const test of tests) {
                if (!testState.running) break;
                await runTest(test);
                await new Promise(resolve => setTimeout(resolve, 100)); // Pause entre tests
            }
        }

        // Event listeners
        document.getElementById('runHighwayTests').addEventListener('click', async () => {
            if (testState.running) return;
            testState.running = true;
            resetStats();
            await runTestSuite(highwayTests, "Tests Autoroute");
            testState.running = false;
        });

        document.getElementById('runEdgeCaseTests').addEventListener('click', async () => {
            if (testState.running) return;
            testState.running = true;
            resetStats();
            await runTestSuite(edgeCaseTests, "Tests Cas Limites");
            testState.running = false;
        });

        document.getElementById('runAllTests').addEventListener('click', async () => {
            if (testState.running) return;
            testState.running = true;
            resetStats();
            await runTestSuite(highwayTests, "Tests Autoroute");
            if (testState.running) {
                await runTestSuite(edgeCaseTests, "Tests Cas Limites");
            }
            testState.running = false;
        });

        document.getElementById('stopTests').addEventListener('click', () => {
            testState.running = false;
            logResult('info', 'Arr√™t', 'Tests interrompus par l\'utilisateur', 0);
        });

        document.getElementById('clearResults').addEventListener('click', () => {
            document.getElementById('testResults').innerHTML = 
                '<div class="test-info">üî¨ Pr√™t √† lancer les tests scientifiques du moteur 6D...</div>';
            resetStats();
        });

        function resetStats() {
            testState.passed = 0;
            testState.failed = 0;
            testState.total = 0;
            updateStats();
            updateProgress();
        }

        // V√©rifier la connexion backend au chargement
        window.addEventListener('load', async () => {
            try {
                const response = await fetch(testState.backendUrl + '/api/health');
                if (response.ok) {
                    logResult('info', 'Backend', '‚úì Connect√© au backend', 0);
                } else {
                    logResult('info', 'Backend', '‚ö†Ô∏è Backend non disponible - Mode simulation', 0);
                }
            } catch (e) {
                logResult('info', 'Backend', '‚ö†Ô∏è Backend non disponible - Mode simulation', 0);
            }
        });

        // Ajouter plus de tests pour atteindre 50 highway et 100 edge cases
        // TODO: Impl√©menter les tests restants selon les cat√©gories
    </script>
</body>
</html> 