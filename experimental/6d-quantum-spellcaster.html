<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåÄ‚ú® 6D Quantum Spellcaster - Magic Stack Integration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #000000 0%, #1a0033 25%, #330066 50%, #000000 100%);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            position: relative;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        #position6d {
            top: 20px;
            left: 20px;
            width: 280px;
        }

        #spells {
            top: 20px;
            right: 20px;
            width: 300px;
        }

        #magicApi {
            bottom: 20px;
            left: 20px;
            width: 400px;
        }

        #status {
            bottom: 20px;
            right: 20px;
            width: 250px;
        }

        .panel-title {
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
        }

        .dimension-group {
            margin-bottom: 12px;
        }

        .dimension-label {
            display: block;
            color: #ffff00;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .dimension-input {
            width: 100%;
            background: #001122;
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .dimension-value {
            color: #ff6b00;
            font-size: 10px;
            margin-top: 2px;
        }

        .spell-button {
            display: block;
            width: 100%;
            background: linear-gradient(45deg, #9400d3, #ff1493);
            color: white;
            border: none;
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .spell-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(148, 0, 211, 0.5);
        }

        .spell-button.casting {
            animation: spellCast 2s ease-in-out;
        }

        @keyframes spellCast {
            0% { background: linear-gradient(45deg, #9400d3, #ff1493); }
            50% { background: linear-gradient(45deg, #00ffff, #ffff00); }
            100% { background: linear-gradient(45deg, #9400d3, #ff1493); }
        }

        .api-status {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: 11px;
        }

        .api-connected {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
        }

        .api-disconnected {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff0000;
        }

        .log-entry {
            font-size: 10px;
            margin: 2px 0;
            padding: 3px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.05);
        }

        .log-spell {
            color: #ff6b00;
        }

        .log-6d {
            color: #00ffff;
        }

        .log-api {
            color: #00ff00;
        }

        .geometry-selector {
            margin: 10px 0;
        }

        .geometry-selector select {
            width: 100%;
            background: #001122;
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        #backButton {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px 15px;
            border: 1px solid #fff;
            border-radius: 15px;
            text-decoration: none;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        #backButton:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-50%) translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="container">
        <a href="../index.html" id="backButton">‚Üê Retour Magic Stack</a>
        
        <!-- 6D Position Panel -->
        <div class="ui-panel" id="position6d">
            <div class="panel-title">üåÄ Position 6D Actuelle</div>
            
            <div class="dimension-group">
                <label class="dimension-label">X (Spatial)</label>
                <input type="range" class="dimension-input" id="posX" min="-10" max="10" step="0.1" value="0">
                <div class="dimension-value" id="posXValue">0.0</div>
            </div>
            
            <div class="dimension-group">
                <label class="dimension-label">Y (Spatial)</label>
                <input type="range" class="dimension-input" id="posY" min="-10" max="10" step="0.1" value="0">
                <div class="dimension-value" id="posYValue">0.0</div>
            </div>
            
            <div class="dimension-group">
                <label class="dimension-label">Z (Spatial)</label>
                <input type="range" class="dimension-input" id="posZ" min="-10" max="10" step="0.1" value="0">
                <div class="dimension-value" id="posZValue">0.0</div>
            </div>
            
            <div class="dimension-group">
                <label class="dimension-label">T (Temporal)</label>
                <input type="range" class="dimension-input" id="posT" min="-100" max="100" step="1" value="0">
                <div class="dimension-value" id="posTValue">0</div>
            </div>
            
            <div class="dimension-group">
                <label class="dimension-label">C (Causal) - "How Real?"</label>
                <input type="range" class="dimension-input" id="posC" min="0" max="1" step="0.01" value="0.95">
                <div class="dimension-value" id="posCValue">0.95</div>
            </div>
            
            <div class="dimension-group">
                <label class="dimension-label">Œ® (Identity) - "Who Am I?"</label>
                <input type="range" class="dimension-input" id="posPsi" min="-1" max="1" step="0.01" value="0.8">
                <div class="dimension-value" id="posPsiValue">0.8</div>
            </div>

            <div class="geometry-selector">
                <label class="dimension-label">G√©om√©trie Quantique</label>
                <select id="quantumGeometry">
                    <option value="hyperbolic">Hyperbolique (C < 0.5)</option>
                    <option value="euclidean" selected>Euclidienne (C ‚âà 0.5)</option>
                    <option value="spherical">Sph√©rique (C > 0.5)</option>
                    <option value="quantum">Superposition Quantique</option>
                </select>
            </div>
        </div>

        <!-- Spell Casting Panel -->
        <div class="ui-panel" id="spells">
            <div class="panel-title">‚ú® Grimoire Quantique (869 Sorts)</div>
            
            <button class="spell-button" onclick="castSpell('REALITY_BEND')">
                üåÄ REALITY_BEND - Courber l'Espace-Temps
            </button>
            
            <button class="spell-button" onclick="castSpell('TEMPORAL_SHIFT')">
                ‚è∞ TEMPORAL_SHIFT - Voyage Temporel
            </button>
            
            <button class="spell-button" onclick="castSpell('CAUSAL_FLUX')">
                üé≤ CAUSAL_FLUX - Modifier la Probabilit√©
            </button>
            
            <button class="spell-button" onclick="castSpell('IDENTITY_MERGE')">
                üë• IDENTITY_MERGE - Fusion d'Identit√©s
            </button>
            
            <button class="spell-button" onclick="castSpell('QUANTUM_TELEPORT')">
                üåü QUANTUM_TELEPORT - T√©l√©portation 6D
            </button>
            
            <button class="spell-button" onclick="castSpell('HYPERBOLIC_STORM')">
                üå™Ô∏è HYPERBOLIC_STORM - Temp√™te G√©om√©trique
            </button>
            
            <button class="spell-button" onclick="castSpell('SPHERICAL_SHIELD')">
                üõ°Ô∏è SPHERICAL_SHIELD - Bouclier Sph√©rique
            </button>
            
            <button class="spell-button" onclick="castSpell('EUCLIDEAN_ANCHOR')">
                ‚öì EUCLIDEAN_ANCHOR - Ancrage Euclidien
            </button>
            
            <button class="spell-button" onclick="castSpell('QSTAR_SEARCH')">
                üîç Q*_SEARCH - Recherche 6D
            </button>
            
            <button class="spell-button" onclick="castSpell('PIZZA_REALITY')">
                üçï PIZZA_REALITY - Analogie Ultime
            </button>
        </div>

        <!-- Magic Stack API Panel -->
        <div class="ui-panel" id="magicApi">
            <div class="panel-title">üì° Magic Stack API Status</div>
            
            <div id="javaStatus" class="api-status api-disconnected">
                ‚òï Java Backend (8082): Disconnected
            </div>
            
            <div id="rustStatus" class="api-status api-disconnected">
                ü¶Ä Rust Backend (3001): Disconnected
            </div>
            
            <div id="pythonStatus" class="api-status api-disconnected">
                üêç Python Router (5000): Disconnected
            </div>
            
            <div style="margin-top: 15px;">
                <div class="dimension-label">üìú Log des Sorts</div>
                <div id="spellLog" style="height: 120px; overflow-y: auto; border: 1px solid #333; padding: 5px; background: rgba(0,0,0,0.5);">
                    <div class="log-entry log-6d">üåÄ Syst√®me 6D initialis√©</div>
                    <div class="log-entry log-api">üì° Tentative de connexion aux backends...</div>
                </div>
            </div>
        </div>

        <!-- Status Panel -->
        <div class="ui-panel" id="status">
            <div class="panel-title">‚ö° √âtat Quantique</div>
            
            <div style="margin: 10px 0;">
                <div class="dimension-label">Distance 6D depuis origine:</div>
                <div id="distance6d" class="dimension-value">0.0</div>
            </div>
            
            <div style="margin: 10px 0;">
                <div class="dimension-label">Coh√©rence Quantique:</div>
                <div id="coherence" class="dimension-value">100%</div>
            </div>
            
            <div style="margin: 10px 0;">
                <div class="dimension-label">G√©om√©trie Active:</div>
                <div id="activeGeometry" class="dimension-value">Euclidienne</div>
            </div>
            
            <div style="margin: 10px 0;">
                <div class="dimension-label">Sorts Lanc√©s:</div>
                <div id="spellCount" class="dimension-value">0</div>
            </div>
            
            <div style="margin: 10px 0;">
                <div class="dimension-label">FPS:</div>
                <div id="fpsCounter" class="dimension-value">60</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script>
        // Variables globales
        let scene, camera, renderer, material;
        let uniforms;
        let clock = new THREE.Clock();
        let frameCount = 0;
        let lastTime = 0;
        let spellCount = 0;

        // Position 6D actuelle
        let position6d = {
            x: 0, y: 0, z: 0,
            t: 0, c: 0.95, psi: 0.8
        };

        // Status des backends
        let backendStatus = {
            java: false,
            rust: false,
            python: false
        };

        // Vertex shader
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Fragment shader avec int√©gration 6D
        const fragmentShader = `
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform int u_geometry;
            uniform vec3 u_position6d_spatial;
            uniform float u_position6d_temporal;
            uniform float u_position6d_causal;
            uniform float u_position6d_identity;
            uniform int u_spell_active;
            uniform float u_spell_power;
            
            varying vec2 vUv;

            #define MAX_STEPS 80
            #define MIN_DIST 0.001
            #define PI 3.14159265359

            // Rotation matrices
            mat3 rotateX(float a) {
                float c = cos(a), s = sin(a);
                return mat3(1, 0, 0, 0, c, -s, 0, s, c);
            }

            mat3 rotateY(float a) {
                float c = cos(a), s = sin(a);
                return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
            }

            // Distance function bas√©e sur la dimension causale
            float quantumSDF(vec3 pos) {
                // La courbure d√©pend de la dimension causale (C)
                float curvature = (u_position6d_causal - 0.5) * 4.0;
                
                if (curvature < -0.1) {
                    // G√©om√©trie hyperbolique (C < 0.5)
                    vec2 p = pos.xy;
                    float r = length(p);
                    if (r >= 0.99) return 0.05;
                    
                    float angle = atan(p.y, p.x);
                    float hypR = 2.0 * atanh(r);
                    
                    float angleStep = PI / 3.0;
                    float radialStep = log(2.0);
                    
                    float modAngle = mod(angle + PI/6.0, angleStep) - angleStep/2.0;
                    float modRadius = mod(hypR, radialStep) - radialStep/2.0;
                    
                    float angleDist = abs(modAngle) * r * 20.0;
                    float radialDist = abs(modRadius) * 10.0;
                    
                    return min(angleDist, radialDist) - 0.02;
                    
                } else if (curvature > 0.1) {
                    // G√©om√©trie sph√©rique (C > 0.5)
                    vec3 p = normalize(pos) * 2.0;
                    float theta = acos(p.z / length(p));
                    float phi = atan(p.y, p.x);
                    
                    float thetaStep = PI / 4.0;
                    float phiStep = PI / 3.0;
                    
                    float modTheta = mod(theta, thetaStep) - thetaStep/2.0;
                    float modPhi = mod(phi + PI/6.0, phiStep) - phiStep/2.0;
                    
                    float thetaDist = abs(modTheta) * 8.0;
                    float phiDist = abs(modPhi) * sin(theta) * 8.0;
                    
                    return min(thetaDist, phiDist) - 0.03;
                    
                } else {
                    // G√©om√©trie euclidienne (C ‚âà 0.5)
                    vec2 p = pos.xy + u_position6d_spatial.xy * 0.1;
                    vec2 grid = abs(fract(p) - 0.5) - 0.4;
                    return min(max(grid.x, grid.y), 0.0) + length(max(grid, 0.0)) - 0.02;
                }
            }

            // Raymarching avec effets quantiques
            float rayMarch(vec3 ro, vec3 rd) {
                float t = 0.0;
                
                for (int i = 0; i < MAX_STEPS; i++) {
                    vec3 pos = ro + t * rd;
                    
                    // Distorsion temporelle bas√©e sur la dimension T
                    pos += sin(pos * 2.0 + u_time + u_position6d_temporal * 0.1) * 0.1 * u_position6d_identity;
                    
                    float d = quantumSDF(pos);
                    
                    // Effet de spell actif
                    if (u_spell_active > 0) {
                        d += sin(length(pos) * 5.0 + u_time * 10.0) * 0.05 * u_spell_power;
                    }
                    
                    if (d < MIN_DIST) break;
                    if (t > 20.0) break;
                    
                    t += d * 0.7;
                }
                
                return t;
            }

            // Calcul des normales
            vec3 calcNormal(vec3 pos) {
                vec2 e = vec2(0.001, 0.0);
                return normalize(vec3(
                    quantumSDF(pos + e.xyy) - quantumSDF(pos - e.xyy),
                    quantumSDF(pos + e.yxy) - quantumSDF(pos - e.yxy),
                    quantumSDF(pos + e.yyx) - quantumSDF(pos - e.yyx)
                ));
            }

            // √âclairage quantique
            vec3 quantumLighting(vec3 pos, vec3 normal, vec3 viewDir) {
                vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                
                // Couleur bas√©e sur les dimensions 6D
                vec3 baseColor = vec3(
                    0.5 + u_position6d_causal * 0.5,
                    0.5 + abs(u_position6d_identity) * 0.5,
                    0.5 + sin(u_position6d_temporal * 0.1) * 0.5
                );
                
                // Effet spell
                if (u_spell_active > 0) {
                    baseColor += vec3(
                        sin(u_time * 20.0) * u_spell_power,
                        cos(u_time * 15.0) * u_spell_power,
                        sin(u_time * 25.0) * u_spell_power
                    ) * 0.3;
                }
                
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                
                vec3 ambient = baseColor * 0.2;
                vec3 diffuse = baseColor * diff * 0.8;
                vec3 specular = vec3(1.0) * spec * 0.5;
                
                return ambient + diffuse + specular;
            }

            void main() {
                vec2 uv = (vUv - 0.5) * 2.0;
                uv.x *= u_resolution.x / u_resolution.y;
                
                vec3 ro = vec3(0, 0, -3) + u_position6d_spatial * 0.1;
                vec3 rd = normalize(vec3(uv, 1.0));
                
                // Rotation bas√©e sur l'identit√©
                rd = rotateY(u_position6d_identity * 0.5) * rotateX(sin(u_time * 0.1) * 0.2) * rd;
                
                float t = rayMarch(ro, rd);
                
                vec3 color = vec3(0.0);
                
                if (t < 20.0) {
                    vec3 pos = ro + t * rd;
                    vec3 normal = calcNormal(pos);
                    vec3 viewDir = -rd;
                    
                    color = quantumLighting(pos, normal, viewDir);
                    
                    // Fog quantique
                    float fog = exp(-t * 0.1);
                    color = mix(vec3(0.0, 0.0, 0.1), color, fog);
                } else {
                    // Background quantique
                    color = mix(
                        vec3(0.0, 0.0, 0.1), 
                        vec3(u_position6d_causal, 0.0, abs(u_position6d_identity)), 
                        uv.y * 0.5 + 0.5
                    );
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function init() {
            // Scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('container').appendChild(renderer.domElement);

            // Uniforms avec int√©gration 6D
            uniforms = {
                u_time: { value: 0 },
                u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                u_geometry: { value: 1 }, // euclidean par d√©faut
                u_position6d_spatial: { value: new THREE.Vector3(0, 0, 0) },
                u_position6d_temporal: { value: 0 },
                u_position6d_causal: { value: 0.95 },
                u_position6d_identity: { value: 0.8 },
                u_spell_active: { value: 0 },
                u_spell_power: { value: 0.0 }
            };

            // Material
            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: uniforms
            });

            // Geometry
            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Setup UI
            setupUI();
            checkBackendStatus();
            animate();
        }

        function setupUI() {
            // Setup sliders pour position 6D
            const sliders = ['posX', 'posY', 'posZ', 'posT', 'posC', 'posPsi'];
            sliders.forEach(name => {
                const slider = document.getElementById(name);
                const display = document.getElementById(name + 'Value');
                
                slider.addEventListener('input', () => {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    
                    // Mettre √† jour position6d
                    if (name === 'posX') position6d.x = value;
                    else if (name === 'posY') position6d.y = value;
                    else if (name === 'posZ') position6d.z = value;
                    else if (name === 'posT') position6d.t = value;
                    else if (name === 'posC') position6d.c = value;
                    else if (name === 'posPsi') position6d.psi = value;
                    
                    update6DPosition();
                });
            });

            // Geometry selector
            document.getElementById('quantumGeometry').addEventListener('change', (e) => {
                const type = e.target.value;
                const geometryMap = {
                    'hyperbolic': 0,
                    'euclidean': 1,
                    'spherical': 2,
                    'quantum': 3
                };
                
                uniforms.u_geometry.value = geometryMap[type];
                document.getElementById('activeGeometry').textContent = 
                    type.charAt(0).toUpperCase() + type.slice(1);
                
                logSpell(`üåÄ G√©om√©trie chang√©e: ${type}`);
            });
        }

        function update6DPosition() {
            // Mettre √† jour les uniforms
            uniforms.u_position6d_spatial.value.set(position6d.x, position6d.y, position6d.z);
            uniforms.u_position6d_temporal.value = position6d.t;
            uniforms.u_position6d_causal.value = position6d.c;
            uniforms.u_position6d_identity.value = position6d.psi;
            
            // Calculer distance 6D
            const distance = Math.sqrt(
                position6d.x*position6d.x + 
                position6d.y*position6d.y + 
                position6d.z*position6d.z + 
                position6d.t*position6d.t*0.01 + 
                position6d.c*position6d.c + 
                position6d.psi*position6d.psi
            );
            
            document.getElementById('distance6d').textContent = distance.toFixed(3);
            
            // Calculer coh√©rence quantique
            const coherence = Math.max(0, 100 - Math.abs(position6d.psi) * 50 - Math.abs(0.5 - position6d.c) * 100);
            document.getElementById('coherence').textContent = coherence.toFixed(1) + '%';
        }

        async function castSpell(spellName) {
            spellCount++;
            document.getElementById('spellCount').textContent = spellCount;
            
            // Animation du bouton
            const button = event.target;
            button.classList.add('casting');
            setTimeout(() => button.classList.remove('casting'), 2000);
            
            // Effet visuel
            uniforms.u_spell_active.value = 1;
            uniforms.u_spell_power.value = 1.0;
            
            setTimeout(() => {
                uniforms.u_spell_active.value = 0;
                uniforms.u_spell_power.value = 0.0;
            }, 3000);
            
            // Log du sort
            logSpell(`‚ú® ${spellName} lanc√©! Position 6D: [${position6d.x.toFixed(2)}, ${position6d.y.toFixed(2)}, ${position6d.z.toFixed(2)}, ${position6d.t}, ${position6d.c.toFixed(2)}, ${position6d.psi.toFixed(2)}]`, 'spell');
            
            // Effets sp√©ciaux par sort
            switch(spellName) {
                case 'REALITY_BEND':
                    position6d.c = Math.max(0, Math.min(1, position6d.c + (Math.random() - 0.5) * 0.2));
                    document.getElementById('posC').value = position6d.c;
                    document.getElementById('posCValue').textContent = position6d.c.toFixed(2);
                    break;
                    
                case 'TEMPORAL_SHIFT':
                    position6d.t += (Math.random() - 0.5) * 20;
                    document.getElementById('posT').value = position6d.t;
                    document.getElementById('posTValue').textContent = position6d.t.toFixed(0);
                    break;
                    
                case 'IDENTITY_MERGE':
                    position6d.psi = Math.max(-1, Math.min(1, position6d.psi + (Math.random() - 0.5) * 0.4));
                    document.getElementById('posPsi').value = position6d.psi;
                    document.getElementById('posPsiValue').textContent = position6d.psi.toFixed(2);
                    break;
                    
                case 'PIZZA_REALITY':
                    logSpell('üçï "Reality is like pizza - it has layers, and the pineapple dimension is controversial"', 'spell');
                    break;
            }
            
            update6DPosition();
            
            // Essayer d'appeler l'API Magic Stack
            await callMagicStackAPI(spellName);
        }

        async function callMagicStackAPI(spellName) {
            const spellData = {
                formula: spellName,
                position6d: position6d,
                parameters: {
                    power: Math.floor(Math.random() * 20) + 1,
                    geometry: document.getElementById('quantumGeometry').value
                }
            };
            
            // Essayer Java backend
            try {
                const response = await fetch('http://localhost:8082/api/magic/cast', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(spellData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    logSpell(`‚òï Java API: ${JSON.stringify(result)}`, 'api');
                    updateBackendStatus('java', true);
                } else {
                    logSpell(`‚òï Java API: Erreur ${response.status}`, 'api');
                }
            } catch (error) {
                updateBackendStatus('java', false);
            }
            
            // Essayer Rust backend
            try {
                const searchData = {
                    query: spellName,
                    center_x: position6d.x,
                    center_y: position6d.y,
                    center_z: position6d.z,
                    center_t: position6d.t,
                    center_c: position6d.c,
                    center_psi: position6d.psi,
                    radius: 10,
                    max_results: 5
                };
                
                const response = await fetch('http://localhost:3001/api/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(searchData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    logSpell(`ü¶Ä Rust Q* Search: ${result.results?.length || 0} r√©sultats`, 'api');
                    updateBackendStatus('rust', true);
                } else {
                    logSpell(`ü¶Ä Rust API: Erreur ${response.status}`, 'api');
                }
            } catch (error) {
                updateBackendStatus('rust', false);
            }
        }

        function updateBackendStatus(backend, connected) {
            backendStatus[backend] = connected;
            const element = document.getElementById(backend + 'Status');
            
            if (connected) {
                element.className = 'api-status api-connected';
                element.textContent = element.textContent.replace('Disconnected', 'Connected');
            } else {
                element.className = 'api-status api-disconnected';
                element.textContent = element.textContent.replace('Connected', 'Disconnected');
            }
        }

        async function checkBackendStatus() {
            // Check p√©riodique des backends
            setInterval(async () => {
                // Test Java
                try {
                    const response = await fetch('http://localhost:8082/api/magic/health');
                    updateBackendStatus('java', response.ok);
                } catch { updateBackendStatus('java', false); }
                
                // Test Rust
                try {
                    const response = await fetch('http://localhost:3001/health');
                    updateBackendStatus('rust', response.ok);
                } catch { updateBackendStatus('rust', false); }
                
                // Test Python
                try {
                    const response = await fetch('http://localhost:5000/');
                    updateBackendStatus('python', response.ok);
                } catch { updateBackendStatus('python', false); }
            }, 5000);
        }

        function logSpell(message, type = 'spell') {
            const log = document.getElementById('spellLog');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Limiter √† 50 entr√©es
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // FPS counter
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fpsCounter').textContent = 
                    Math.round(frameCount * 1000 / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
            }
            
            uniforms.u_time.value = clock.getElapsedTime();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        // Initialize
        init();
    </script>
</body>
</html>